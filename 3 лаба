#include <iostream>
#include <stdexcept>

template <typename T>
class LinkedList {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& value) : data(value), next(nullptr) {}
    };

    Node* head;

    void copyFrom(const LinkedList& other) {
        if (other.head == nullptr) {
            head = nullptr;
            return;
        }
        head = new Node(other.head->data);
        Node* current = head;
        Node* otherCurrent = other.head->next;
        while (otherCurrent) {
            current->next = new Node(otherCurrent->data);
            current = current->next;
            otherCurrent = otherCurrent->next;
        }
    }

public:
    LinkedList() : head(nullptr) {}

    LinkedList(const LinkedList& other) : head(nullptr) {
        copyFrom(other);
    }

    //Оператор присвоения
    LinkedList& operator=(const LinkedList& other) {
        if (this != &other) {
            clear();
            copyFrom(other);
        }
        return *this;
    }

    ~LinkedList() {
        clear();
    }

    //Добавление в конец списка
    void push_back(const T& value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next)
                temp = temp->next;
            temp->next = newNode;
        }
    }

    //Оператор сложения для объединения списков
    LinkedList operator+(const LinkedList& other) const {
        LinkedList result(*this);
        Node* current = result.head;
        if (!current) {
            result.copyFrom(other);
            return result;
        }
        while (current->next)
            current = current->next;
        Node* otherCurr = other.head;
        while (otherCurr) {
            current->next = new Node(otherCurr->data);
            current = current->next;
            otherCurr = otherCurr->next;
        }
        return result;
    }

    //Оператор доступа по индексу с проверкой
    T& operator[](size_t index) {
        Node* current = head;
        size_t i = 0;
        while (current && i < index) {
            current = current->next;
            i++;
        }
        if (!current)
            throw std::out_of_range("Index out of range");
        return current->data;
    }

    const T& operator[](size_t index) const {
        Node* current = head;
        size_t i = 0;
        while (current && i < index) {
            current = current->next;
            i++;
        }
        if (!current)
            throw std::out_of_range("Index out of range");
        return current->data;
    }

    //Оператор сравнения 
    bool operator==(const LinkedList& other) const {
        Node* a = head;
        Node* b = other.head;
        while (a && b) {
            if (a->data != b->data)
                return false;
            a = a->next;
            b = b->next;
        }
        return a == nullptr && b == nullptr;
    }

    bool operator!=(const LinkedList& other) const {
        return !(*this == other);
    }

    void clear() {
        Node* current = head;
        while (current) {
            Node* toDel = current;
            current = current->next;
            delete toDel;
        }
        head = nullptr;
    }

    //Вывод списка
    void print() const {
        Node* current = head;
        while (current) {
            std::cout << current->data << " -> ";
            current = current->next;
        }
        std::cout << "nullptr\n";
    }

    //Перегрузка оператора вывода в поток
    friend std::ostream& operator<<(std::ostream& os, const LinkedList& list) {
        Node* current = list.head;
        while (current) {
            os << current->data << " -> ";
            current = current->next;
        }
        os << "nullptr";
        return os;
    }
};

int main() {
    LinkedList<int> list1;
    list1.push_back(1);
    list1.push_back(2);
    list1.push_back(3);

    LinkedList<int> list2;
    list2.push_back(4);
    list2.push_back(5);

    LinkedList<int> list3 = list1 + list2;  //объединение списков

    std::cout << "Список1: " << list1 << std::endl;
    std::cout << "Список2: " << list2 << std::endl;
    std::cout << "Список3 (Список1 + Список2): " << list3 << std::endl;

    if (list1 != list2) {
        std::cout << "Списки разливаются между собой\n";
    }

    std::cout << "Элемент с индексом 1 в списке3: " << list3[1] << std::endl;

    return 0;
}
