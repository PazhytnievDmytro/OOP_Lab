# Лабораторная работа 7: Обработка ошибок и исключений

## Обработка ошибок, исключения

### Задание
Необходимо написать код, который иллюстрирует использование исключений для обработки исключительных ситуаций. Используя ключевые слова throw, try и catch, нужно обработать несколько разных ислючений. Также нужно показать эффект исключений разных типов в рамках одного блока try-catch и восстановление программы после обработки исключения.

---

## Теоритические сведения
### 7.1. Механизм исключений
Механизм исключений в C++ представляет собой способ обработки ошибок и особых ситуаций, возникающих во время выполнения программы. Исключение — это объект, который генерируется при возникновении ошибки и передаётся вверх по стеку вызовов до тех пор, пока не будет перехвачен соответствующим обработчиком.

Ключевые слова механизма исключений: throw — для генерации исключения, try — для обозначения блока кода, в котором могут возникать исключения, catch — для определения обработчика исключения конкретного типа.

При генерации исключения выполнение текущей функции немедленно прекращается, и начинается процесс раскрутки стека (stack unwinding): деструкторы всех локальных объектов в текущей функции и всех функций в стеке вызовов автоматически вызываются, после чего поиск обработчика исключения продолжается в вызывающей функции.

### 7.2. Иерархия стандартных исключений
Все стандартные исключения C++ образуют иерархию, корнем которой является класс std::exception из заголовочного файла . Базовый класс предоставляет виртуальный метод what(), возвращающий строку с описанием ошибки.

Основные производные классы исключений включают: std::logic_error — ошибки в логике программы (неверные предусловия, инварианты и т.д.), с производными std::invalid_argument, std::domain_error, std::length_error, std::out_of_range; std::runtime_error — ошибки времени выполнения, не зависящие от логики программы, с производными std::range_error, std::overflow_error, std::underflow_error.

### 7.3. Пользовательские типы исключений
Создание пользовательских типов исключений позволяет инкапсулировать специфическую информацию об ошибке и интегрировать её в иерархию стандартных исключений. Пользовательский класс исключения обычно наследует от std::exception или одного из его производных классов.

Рекомендуется переопределить метод what() для предоставления осмысленного описания ошибки. Для исключений, требующих дополнительной информации (коды ошибок, контекст и т.д.), можно определить дополнительные методы доступа к этой информации.

### 7.4. Обработка нескольких типов исключений
Блок try может содержать несколько блоков catch для обработки исключений различных типов. Блоки catch проверяются по порядку, поэтому более специфичные типы исключений должны располагаться раньше более общих. Блок catch(...) перехватывает исключения любого типа и должен быть последним в последовательности.

При возникновении исключения управление передаётся первому подходящему блоку catch, после чего выполнение продолжается с точки, следующей за блоком try-catch.

### 7.5. Повторный выброс исключения
Исключение может быть повторно выброшено в блоке catch с помощью ключевого слова throw без аргументов. Это позволяет выполнить частичную обработку исключения (например, логирование) в одном месте, а затем передать исключение на обработку в другое место.

### 7.6. Гарантии безопасности исключений
При проектировании функций с точки зрения безопасности исключений выделяют несколько уровней гарантий: базовую гарантию (no-leak guarantee) — при исключении программа остаётся в корректном состоянии, все ресурсы освобождаются; строгую гарантию (strong guarantee) — при исключении состояние программы не изменяется (операция либо выполняется полностью, либо не изменяет состояния); гарантию nothrow — функция не генерирует исключений и всегда успешно завершается. Для функций, не предназначенных для генерации исключений, можно использовать спецификацию noexcept: void function() noexcept { ... }.

---

Особенности реализации:
- Множественные блоки catch для разных типов исключений
- Иерархия исключений (наследование от std::exception)
- Раскрутка стека (stack unwinding) - автоматический вызов деструкторов
- Повторный выброс исключения (rethrow)
- Восстановление программы после обработки исключения
- Инкапсуляция дополнительной информации в пользовательских исключениях


 ## Код программы:
    #include <iostream>
    #include <string>
    #include <vector>
    #include <stdexcept>
    #include <memory>
    #include <cmath>
    #include <functional>
    
    class MathException : public std::runtime_error {
    private:
        std::string operation;
        double operand1;
        double operand2;
    
        public:
            MathException(const std::string& msg, const std::string& op, double a, double b)
                : std::runtime_error(msg), operation(op), operand1(a), operand2(b) {}
    
        const std::string& getOperation() const { return operation; }
        double getOperand1() const { return operand1; }
        double getOperand2() const { return operand2; }
    
        void printDetails() const {
            std::cout << "Операция: " << operation << "\n";
            std::cout << "Первый операнд: " << operand1 << "\n";
            std::cout << "Второй операнд: " << operand2 << "\n";
        }
    };
    
    class DatabaseException : public std::exception {
    private:
        std::string message;
        int errorCode;
        std::string tableName;
    
    public:
        DatabaseException(const std::string& msg, int code, const std::string& table)
            : message(msg), errorCode(code), tableName(table) {}
    
        const char* what() const noexcept override {
            return message.c_str();
        }
    
        int getErrorCode() const { return errorCode; }
        const std::string& getTableName() const { return tableName; }
    };
    
    class ValidationException : public std::exception {
    private:
        std::string fieldName;
        std::string invalidValue;
    
    public:
        ValidationException(const std::string& field, const std::string& value)
            : fieldName(field), invalidValue(value) {}
    
        const char* what() const noexcept override {
            static std::string msg;
            msg = "Ошибка валидации поля '" + fieldName + "': недопустимое значение '" + invalidValue + "'";
            return msg.c_str();
        }
    
        const std::string& getFieldName() const { return fieldName; }
        const std::string& getInvalidValue() const { return invalidValue; }
    };
    
    double divide(double a, double b) {
        if (b == 0) {
            throw std::invalid_argument("Деление на ноль: делитель не может быть равен нулю");
        }
        return a / b;
    }
    
    double squareRoot(double value) {
        if (value < 0) {
            throw std::domain_error("Извлечение корня из отрицательного числа");
        }
        return std::sqrt(value);
    }
    
    int factorial(int n) {
        if (n < 0) {
            throw std::invalid_argument("Факториал отрицательного числа не определён");
        }
        if (n > 20) {
            throw std::overflow_error("Факториал слишком большой, произойдёт переполнение");
        }
        int result = 1;
        for (int i = 2; i <= n; ++i) {
            result *= i;
        }
        return result;
    }
    
    int arrayAccess(const std::vector<int>& arr, int index) {
        if (index < 0 || index >= static_cast<int>(arr.size())) {
            throw std::out_of_range("Индекс выходит за пределы массива");
        }
        return arr[index];
    }
    
    void validateUserInput(const std::string& name, int age, const std::string& email) {
        if (name.empty()) {
            throw ValidationException("name", "пустая строка");
        }
        if (age < 0 || age > 150) {
            throw ValidationException("age", std::to_string(age));
        }
        if (email.find('@') == std::string::npos) {
            throw ValidationException("email", email);
        }
    }
    
    void performComplexCalculation(double x, double y, const std::string& operation) {
        try {
            if (operation == "divide") {
                double result = divide(x, y);
                std::cout << "Результат деления: " << result << "\n";
            }
            else if (operation == "sqrt") {
                double result = squareRoot(x);
                std::cout << "Квадратный корень: " << result << "\n";
            }
            else if (operation == "factorial") {
                int result = factorial(static_cast<int>(x));
                std::cout << "Факториал: " << result << "\n";
            }
            else {
                throw std::invalid_argument("Неизвестная операция: " + operation);
            }
        }
        catch (const std::invalid_argument& e) {
            std::cout << "Перехвачено std::invalid_argument: " << e.what() << "\n";
            throw MathException("Ошибка в математической операции", operation, x, y);
        }
        catch (const std::domain_error& e) {
            std::cout << "Перехвачено std::domain_error: " << e.what() << "\n";
            throw MathException("Ошибка области определения", operation, x, y);
        }
        catch (const std::overflow_error& e) {
            std::cout << "Перехвачено std::overflow_error: " << e.what() << "\n";
            throw MathException("Ошибка переполнения", operation, x, y);
        }
    }
    
    void processDataWithRecovery() {
        static int attemptCount = 0;
        attemptCount++;
    
        std::vector<int> data = {1, 2, 3, 4, 5};
    
        try {
            std::cout << "\nПопытка " << attemptCount << " обработки данных:\n";
            int value = arrayAccess(data, 10);
            std::cout << "Значение: " << value << "\n";
        }
        catch (const std::out_of_range& e) {
            std::cout << "Исключение перехвачено: " << e.what() << "\n";
            std::cout << "Восстановление: используется значение по умолчанию\n";
            std::cout << "Программа продолжает работу после обработки исключения\n";
        }
    }
    
    void demonstrateMultipleExceptionTypes() {
        std::cout << "\nДемонстрация разных типов исключений в одном блоке try-catch:\n";
    
        std::cout << "\nТест 1: Деление на ноль\n";
        try {
            divide(10, 0);
        }
        catch (const std::invalid_argument& e) {
            std::cout << "  -> std::invalid_argument: " << e.what() << "\n";
        }
        catch (const std::exception& e) {
            std::cout << "  -> std::exception: " << e.what() << "\n";
        }
    
        std::cout << "\nТест 2: Корень из отрицательного\n";
        try {
            squareRoot(-5);
        }
        catch (const std::domain_error& e) {
            std::cout << "  -> std::domain_error: " << e.what() << "\n";
        }
        catch (const std::exception& e) {
            std::cout << "  -> std::exception: " << e.what() << "\n";
        }
    
        std::cout << "\nТест 3: Факториал отрицательного\n";
        try {
            factorial(-3);
        }
        catch (const std::invalid_argument& e) {
            std::cout << "  -> std::invalid_argument: " << e.what() << "\n";
        }
        catch (const std::exception& e) {
            std::cout << "  -> std::exception: " << e.what() << "\n";
        }
    
        std::cout << "\nТест 4: Индекс за пределами массива\n";
        try {
            std::vector<int> arr = {1, 2, 3};
            arrayAccess(arr, 10);
        }
        catch (const std::out_of_range& e) {
            std::cout << "  -> std::out_of_range: " << e.what() << "\n";
        }
        catch (const std::exception& e) {
            std::cout << "  -> std::exception: " << e.what() << "\n";
        }
    }
    
    void demonstrateCustomExceptions() {
        std::cout << "\nДемонстрация пользовательских типов исключений:\n";
    
        try {
            throw MathException("Ошибка вычисления", "division", 42.0, 0.0);
        }
        catch (const MathException& e) {
            std::cout << "Перехвачено MathException: " << e.what() << "\n";
            e.printDetails();
        }
    
        std::cout << "\n";
        try {
            throw DatabaseException("Ошибка подключения к базе данных", 1001, "users");
        }
        catch (const DatabaseException& e) {
            std::cout << "Перехвачено DatabaseException\n";
            std::cout << "  Код ошибки: " << e.getErrorCode() << "\n";
            std::cout << "  Таблица: " << e.getTableName() << "\n";
        }
    
        std::cout << "\n";
        try {
            throw ValidationException("age", "200");
        }
        catch (const ValidationException& e) {
            std::cout << "Перехвачено ValidationException: " << e.what() << "\n";
        }
    }
    
    void demonstrateExceptionHandling() {
        std::cout << "\nДемонстрация восстановления после исключения:\n";
    
        double values[] = {16.0, 4.0, 0.0, -4.0, 9.0};
    
        for (int i = 0; i < 5; ++i) {
            try {
                std::cout << "\nОбработка значения " << values[i] << ":\n";
                double result = squareRoot(values[i]);
                std::cout << "  Квадратный корень: " << result << "\n";
            }
            catch (const std::domain_error& e) {
                std::cout << "  Исключение: " << e.what() << "\n";
                std::cout << "  Пропуск этого значения, продолжение обработки...\n";
            }
        }
    }
    
    void demonstrateStackUnwinding() {
        std::cout << "\nДемонстрация раскрутки стека (stack unwinding):\n";
    
        struct Resource {
            std::string resName;
            Resource(const std::string& n) : resName(n) {
                std::cout << "Создание ресурса: " << resName << "\n";
            }
            ~Resource() {
                std::cout << "Освобождение ресурса: " << resName << "\n";
            }
        };
    
        try {
            Resource r1("ресурс_1");
            std::cout << "Генерация исключения...\n";
            throw std::runtime_error("Тестовое исключение");
            Resource r2("ресурс_2");
        }
        catch (const std::exception& e) {
            std::cout << "Исключение перехвачено: " << e.what() << "\n";
        }
        std::cout << "Программа продолжает работу после блока try-catch\n";
    }
    
    void demonstrateRethrow() {
        std::cout << "\nДемонстрация повторного выброса исключения:\n";
    
        try {
            try {
                throw std::runtime_error("Внутреннее исключение");
            }
            catch (...) {
                std::cout << "Повторный выброс исключения...\n";
                throw;
            }
        }
        catch (const std::exception& e) {
            std::cout << "Внешний перехват: " << e.what() << "\n";
        }
    }
    
    void demonstrateTryCatchMultiple() {
        std::cout << "\nДемонстрация нескольких блоков catch:\n";
    
        std::cout << "\nТест: Деление на ноль\n";
        try {
            divide(100, 0);
        }
        catch (const MathException& e) {
            std::cout << "  MathException: " << e.what() << "\n";
            std::cout << "  Операция: " << e.getOperation() << "\n";
        }
        catch (const std::invalid_argument& e) {
            std::cout << "  std::invalid_argument: " << e.what() << "\n";
        }
        catch (const std::overflow_error& e) {
            std::cout << "  std::overflow_error: " << e.what() << "\n";
        }
        catch (...) {
            std::cout << "  Неизвестное исключение\n";
        }
    
        std::cout << "\nТест: Факториал > 20\n";
        try {
            factorial(25);
        }
        catch (const MathException& e) {
            std::cout << "  MathException: " << e.what() << "\n";
            std::cout << "  Операция: " << e.getOperation() << "\n";
        }
        catch (const std::invalid_argument& e) {
            std::cout << "  std::invalid_argument: " << e.what() << "\n";
        }
        catch (const std::overflow_error& e) {
            std::cout << "  std::overflow_error: " << e.what() << "\n";
        }
        catch (...) {
            std::cout << "  Неизвестное исключение\n";
        }
    
        std::cout << "\nТест: Недопустимая операция\n";
        try {
            performComplexCalculation(5, 5, "unknown");
        }
        catch (const MathException& e) {
            std::cout << "  MathException: " << e.what() << "\n";
            std::cout << "  Операция: " << e.getOperation() << "\n";
        }
        catch (const std::invalid_argument& e) {
            std::cout << "  std::invalid_argument: " << e.what() << "\n";
        }
        catch (const std::overflow_error& e) {
            std::cout << "  std::overflow_error: " << e.what() << "\n";
        }
        catch (...) {
            std::cout << "  Неизвестное исключение\n";
        }
    }
    
    int main() {
        std::cout << "Лабораторная работа 7: Обработка ошибок, исключения\n\n";
    
        std::cout << "Базовые исключения стандартной библиотеки\n";
        double divResult = divide(10, 2);
        std::cout << "10 / 2 = " << divResult << "\n";
    
        try {
            divide(10, 0);
        }
        catch (const std::invalid_argument& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        try {
            squareRoot(-5);
        }
        catch (const std::domain_error& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        try {
            factorial(-5);
        }
        catch (const std::invalid_argument& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        try {
            factorial(25);
        }
        catch (const std::overflow_error& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        std::cout << "\nВалидация входных данных\n";
        try {
            validateUserInput("", 25, "test@email.com");
        }
        catch (const ValidationException& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        try {
            validateUserInput("John", 200, "test@email.com");
        }
        catch (const ValidationException& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        try {
            validateUserInput("John", 25, "invalid-email");
        }
        catch (const ValidationException& e) {
            std::cout << "Исключение: " << e.what() << "\n";
        }
    
        demonstrateMultipleExceptionTypes();
        demonstrateCustomExceptions();
        demonstrateExceptionHandling();
        demonstrateStackUnwinding();
        demonstrateRethrow();
        demonstrateTryCatchMultiple();
    
        for (int i = 0; i < 3; ++i) {
            processDataWithRecovery();
        }
    
        std::cout << "\nВсе демонстрации завершены\n";
        return 0;
    }


## Объяснение всех уникальных и важных строк в программе
class MathException : public std::runtime_error { ... } - пользовательский класс исключения, наследующий от std::runtime_error

private: - закрытая секция класса

std::string operation; - поле для хранения названия операции

double operand1; - поле для хранения первого операнда

double operand2; - поле для хранения второго операнда

public: - открытая секция класса

MathException(const std::string& msg, const std::string& op, double a, double b) - конструктор с параметрами

: std::runtime_error(msg), operation(op), operand1(a), operand2(b) {} - список инициализации, вызов конструктора базового класса

const std::string& getOperation() const { return operation; } - метод для получения названия операции

double getOperand1() const { return operand1; } - метод для получения первого операнда

double getOperand2() const { return operand2; } - метод для получения второго операнда

void printDetails() const { ... } - метод для вывода деталей исключения

class DatabaseException : public std::exception { ... } - пользовательский класс исключения для ошибок базы данных

DatabaseException(const std::string& msg, int code, const std::string& table) - конструктор

const char* what() const noexcept override { ... } - переопределение метода what()

int getErrorCode() const { return errorCode; } - метод для получения кода ошибки

const std::string& getTableName() const { return tableName; } - метод для получения имени таблицы

class ValidationException : public std::exception { ... } - пользовательский класс исключения для ошибок валидации

ValidationException(const std::string& field, const std::string& value) - конструктор

const char* what() const noexcept override { ... } - переопределение метода what()

double divide(double a, double b) { ... } - функция деления двух чисел

if (b == 0) { throw std::invalid_argument("Деление на ноль..."); } - проверка делителя на ноль, выброс исключения

double squareRoot(double value) { ... } - функция вычисления квадратного корня

if (value < 0) { throw std::domain_error("Извлечение корня..."); } - проверка на отрицательное значение

int factorial(int n) { ... } - функция вычисления факториала

if (n < 0) { throw std::invalid_argument("Факториал отрицательного..."); } - проверка на отрицательное число

if (n > 20) { throw std::overflow_error("Факториал слишком большой..."); } - проверка на переполнение

int arrayAccess(const std::vector& arr, int index) { ... } - функция доступа к элементу массива

if (index < 0 || index >= static_cast(arr.size())) { throw std::out_of_range("Индекс выходит..."); } - проверка индекса

void validateUserInput(...) { ... } - функция валидации входных данных

if (name.empty()) { throw ValidationException("name", "пустая строка"); } - проверка имени

if (age < 0 || age > 150) { throw ValidationException("age", ...); } - проверка возраста

if (email.find('@') == std::string::npos) { throw ValidationException("email", email); } - проверка email

void performComplexCalculation(double x, double y, const std::string& operation) { ... } - функция с вложенными try-catch

catch (const std::invalid_argument& e) { ... throw MathException(...); } - перехват и повторный выброс

void processDataWithRecovery() { ... } - функция демонстрации восстановления после исключения

catch (const std::out_of_range& e) { ... std::cout << "Программа продолжает работу..."; } - обработка и восстановление

void demonstrateMultipleExceptionTypes() { ... } - демонстрация разных типов исключений в одном блоке

catch (const std::invalid_argument& e) { ... } - перехват invalid_argument

catch (const std::domain_error& e) { ... } - перехват domain_error

catch (const std::out_of_range& e) { ... } - перехват out_of_range

catch (const std::exception& e) { ... } - перехват базового класса exception

void demonstrateStackUnwinding() { ... } - демонстрация раскрутки стека

try { Resource r1("ресурс_1"); throw std::runtime_error(...); Resource r2(...); } - создание объектов

catch (const std::exception& e) { ... } - перехват исключения

~Resource() { std::cout << "Освобождение ресурса: " << name; } - деструктор освобождает ресурс

void demonstrateRethrow() { ... } - демонстрация повторного выброса исключения

throw; - повторный выброс текущего исключения

throw std::invalid_argument("Сообщение"); - генерация исключения с текстом ошибки

try { ... } catch (const std::invalid_argument& e) { ... } - блок try-catch для перехвата

catch (...) { ... } - перехват любых исключений






















