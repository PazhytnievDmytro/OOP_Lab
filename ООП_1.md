# Лабораторная работа 1
## Абстрактные типы данных
### Задание
Используя язык С++, необходимо создать свой тип данных и соответствующие ему операции. Тип данных создается с помощью ключевого слова class или struct. В зависимости от этого необходимо правильно использовать метки public и private для иллюстрации принципа инкапсуляции в объектно-ориентированном программировании. 

---

№№ Теоритические сведения
### 1.1. Понятие абстрактного типа данных
Абстрактный тип данных (АТД) представляет собой фундаментальное понятие в программировании, которое отделяет логическое описание типа данных от его конкретной реализации. АТД определяется набором операций, которые могут быть выполнены над данным типом, независимо от того, как эти операции реализованы внутри. Такой подход позволяет программистам работать с данными на высоком уровне абстракции, не задумываясь о деталях внутреннего представления.

Основная идея абстракции заключается в том, чтобы скрыть сложность реализации за простым и понятным интерфейсом. Пользователь типа данных взаимодействует с ним только через публичные методы, в то время как внутренняя реализация остаётся скрытой и может быть изменена без влияния на использующий код. Это обеспечивает модульность программного обеспечения и упрощает его сопровождение.

Классическими примерами абстрактных типов данных являются стек, очередь, список, дерево, хэш-таблица и другие структуры данных. Каждый из этих типов характеризуется определённым набором операций: для стека это операции push (добавление элемента), pop (извлечение элемента) и peek (просмотр верхнего элемента); для очереди — enqueue (добавление в конец) и dequeue (извлечение из начала).

### 1.2. Инкапсуляция как фундаментальный принцип ООП
Инкапсуляция представляет собой один из базовых принципов объектно-ориентированного программирования и заключается в объединении данных и методов их обработки в единую сущность (объект), а также в ограничении доступа к внутренним компонентам объекта. Инкапсуляция обеспечивает защиту данных от некорректного использования и скрывает сложность реализации от пользователя.

В языке C++ инкапсуляция реализуется посредством использования классов и меток доступа. Класс служит основным механизмом для создания пользовательских типов данных, а метки доступа public и private определяют уровень видимости членов класса. Члены класса, объявленные как private, недоступны извне класса и могут использоваться только внутри методов самого класса. Члены класса, объявленные как public, напротив, доступны из любой части программы и формируют открытый интерфейс класса.

Инкапсуляция предоставляет несколько важных преимуществ для разработки программного обеспечения. Во-первых, она защищает целостность данных, предлагая контролируемый доступ к внутреннему состоянию объекта через методы-аксессоры. Во-вторых, инкапсуляция позволяет скрыть детали реализации, что упрощает работу с кодом и делает его более понятным. В-третьих, изменения во внутренней реализации класса не затрагивают код, использующий этот класс, при условии сохранения открытого интерфейса.

### 1.3. Классы и структуры в C++
В языке C++ для создания пользовательских типов данных используются ключевые слова class и struct. Оба механизма позволяют определять составные типы данных с полями и методами, однако между ними существует принципиальное различие в уровне доступа по умолчанию. Для класса члены являются закрытыми (private) по умолчанию, тогда как для структуры члены являются открытыми (public) по умолчанию.

Выбор между class и struct определяется семантикой создаваемого типа данных. Традиционно struct используется для простых агрегатных типов данных, где основной целью является группировка связанных данных без сложной логики. Класс же применяется для создания более сложных абстрактных типов данных, где важна инкапсуляция и сокрытие внутренней реализации.

---

## Код программы
    #include <iostream>
    #include <cassert>
    #include <stdexcept>
    #include <sstream>
    
    class Fraction {
    private:
        long long numerator;
        long long denominator;
    
        void reduce() {
            if (denominator < 0) {
                numerator = -numerator;
                denominator = -denominator;
            }
            long long a = numerator;
            long long b = denominator;
            while (b != 0) {
                long long temp = a % b;
                a = b;
                b = temp;
            }
            long long gcd = (a < 0) ? -a : a;
            if (gcd > 1) {
                numerator /= gcd;
                denominator /= gcd;
            }
        }
    
    public:
        Fraction() : numerator(0), denominator(1) {}
    
        Fraction(long long num, long long den) : numerator(num), denominator(den) {
            if (den == 0) {
                throw std::invalid_argument("знаменатель не может быть равен нулю");
            }
            reduce();
        }
    
        Fraction(const Fraction& other) : numerator(other.numerator), denominator(other.denominator) {}
    
        ~Fraction() {}
    
        long long getNumerator() const { return numerator; }
        long long getDenominator() const { return denominator; }
    
        Fraction add(const Fraction& other) const {
            long long num = numerator * other.denominator + other.numerator * denominator;
            long long den = denominator * other.denominator;
            return Fraction(num, den);
        }
    
        Fraction subtract(const Fraction& other) const {
            long long num = numerator * other.denominator - other.numerator * denominator;
            long long den = denominator * other.denominator;
            return Fraction(num, den);
        }
    
        Fraction multiply(const Fraction& other) const {
            long long num = numerator * other.numerator;
            long long den = denominator * other.denominator;
            return Fraction(num, den);
        }
    
        Fraction divide(const Fraction& other) const {
            if (other.numerator == 0) {
                throw std::runtime_error("Деление на ноль");
            }
            long long num = numerator * other.denominator;
            long long den = denominator * other.numerator;
            return Fraction(num, den);
        }
    
        bool equals(const Fraction& other) const {
            return numerator == other.numerator && denominator == other.denominator;
        }
    
        bool greaterThan(const Fraction& other) const {
            return numerator * other.denominator > other.numerator * denominator;
        }
    
        bool lessThan(const Fraction& other) const {
            return numerator * other.denominator < other.numerator * denominator;
        }
    
        double toDouble() const {
            return static_cast<double>(numerator) / static_cast<double>(denominator);
        }
    
        std::string toString() const {
            std::ostringstream oss;
            oss << numerator << "/" << denominator;
            return oss.str();
        }
    
        Fraction operator+(const Fraction& other) const { return add(other); }
        Fraction operator-(const Fraction& other) const { return subtract(other); }
        Fraction operator*(const Fraction& other) const { return multiply(other); }
        Fraction operator/(const Fraction& other) const { return divide(other); }
        bool operator==(const Fraction& other) const { return equals(other); }
        bool operator!=(const Fraction& other) const { return !equals(other); }
        bool operator>(const Fraction& other) const { return greaterThan(other); }
        bool operator<(const Fraction& other) const { return lessThan(other); }
        bool operator>=(const Fraction& other) const { return !lessThan(other); }
        bool operator<=(const Fraction& other) const { return !greaterThan(other); }
    };
    
    Fraction createFraction(long long num, long long den) {
        return Fraction(num, den);
    }
    
    void printFraction(const Fraction& f) {
        std::cout << f.toString();
    }
    
    int main() {
        std::cout << "Создание и базовые операции:\n";
        Fraction a(2, 4);
        Fraction b(1, 3);
    
        std::cout << "Дробь a = " << a.toString() << " = " << a.toDouble() << "\n";
        std::cout << "Дробь b = " << b.toString() << " = " << b.toDouble() << "\n\n";
    
        std::cout << "Арифметические операции:\n";
        Fraction sum = a.add(b);
        std::cout << a.toString() << " + " << b.toString() << " = " << sum.toString() << "\n";
    
        Fraction diff = a.subtract(b);
        std::cout << a.toString() << " - " << b.toString() << " = " << diff.toString() << "\n";
    
        Fraction prod = a.multiply(b);
        std::cout << a.toString() << " * " << b.toString() << " = " << prod.toString() << "\n";
    
        Fraction quot = a.divide(b);
        std::cout << a.toString() << " / " << b.toString() << " = " << quot.toString() << "\n\n";
    
        std::cout << "Перегруженные операторы C++:\n";
        Fraction c = a + b;
        Fraction d = a - b;
        Fraction e = a * b;
        Fraction f = a / b;
    
        std::cout << "a + b = " << c.toString() << "\n";
        std::cout << "a - b = " << d.toString() << "\n";
        std::cout << "a * b = " << e.toString() << "\n";
        std::cout << "a / b = " << f.toString() << "\n\n";
    
        std::cout << "Операции сравнения:\n";
        Fraction x(1, 2);
        Fraction y(2, 4);
    
        std::cout << "x = " << x.toString() << ", y = " << y.toString() << "\n";
        std::cout << "x == y: " << (x.equals(y) ? "правда" : "ложь") << "\n";
        std::cout << "x > b: " << (x.greaterThan(b) ? "правда" : "ложь") << "\n";
        std::cout << "x < b: " << (x.lessThan(b) ? "правда" : "ложь") << "\n\n";
    
        try {
            Fraction invalid(1, 0);
        } catch (const std::invalid_argument& e) {
            std::cout << "Перехвачено исключение: " << e.what() << "\n";
        }
    
        try {
            Fraction zero(0, 1);
            Fraction result = zero.divide(a);
        } catch (const std::runtime_error& e) {
            std::cout << "Перехвачено исключение: " << e.what() << "\n";
        }
        return 0;
    }


## Объяснения:
- class Fraction { – объявление класса Fraction для представления дробей.

- long long numerator; – целочисленная переменная для хранения числителя дроби.

- long long denominator; – целочисленная переменная для хранения знаменателя дроби.

- void reduce() { – объявление приватного метода для сокращения дроби (приведения к несократимому виду).

- if (denominator < 0) { numerator = -numerator; denominator = -denominator; } – алгоритм: если знаменатель отрицательный, знак переносится в числитель.

- long long gcd = (a < 0) ? -a : a; – вычисление наибольшего общего делителя (НОД) числителя и знаменателя, взятие модуля.

- Fraction(long long num, long long den) : numerator(num), denominator(den) { – объявление основного конструктора с параметрами.

- if (den == 0) { throw std::invalid_argument("знаменатель не может быть равен нулю"); } – проверка: создание дроби с нулевым знаменателем вызывает исключение.

- Fraction add(const Fraction& other) const { – метод для сложения двух дробей.

- long long num = numerator * other.denominator + other.numerator * denominator; – формула вычисления нового числителя при сложении дробей.

- Fraction divide(const Fraction& other) const { if (other.numerator == 0) { throw std::runtime_error("Деление на ноль"); } – метод деления дробей с проверкой деления на ноль (проверяется числитель делителя).

- bool greaterThan(const Fraction& other) const { return numerator * other.denominator > other.numerator * denominator; } – метод сравнения "больше" без приведения к вещественному типу.

- double toDouble() const { return static_cast<double>(numerator) / static_cast<double>(denominator); } – метод преобразования дроби в вещественное число типа double.

- std::string toString() const { std::ostringstream oss; oss << numerator << "/" << denominator; return oss.str(); } – метод преобразования дроби в строку вида "числитель/знаменатель".

- Fraction operator+(const Fraction& other) const { return add(other); } – перегрузка оператора + для использования синтаксиса a + b.

- bool operator==(const Fraction& other) const { return equals(other); } – перегрузка оператора сравнения на равенство ==.

- Fraction createFraction(long long num, long long den) { return Fraction(num, den); } – свободная функция для создания объекта Fraction.

- void printFraction(const Fraction& f) { std::cout << f.toString(); } – свободная функция для печати дроби в консоль.

- Fraction a(2, 4); – создание дроби 2/4, которая внутри конструктора будет автоматически сокращена до 1/2.

- Fraction sum = a.add(b); – пример использования метода add для сложения дробей.

- Fraction c = a + b; – пример использования перегруженного оператора + для сложения дробей.

- std::cout << "x == y: " << (x.equals(y) ? "правда" : "ложь") << "\n"; – пример использования метода equals для сравнения дробей.

- try { Fraction invalid(1, 0); } catch (const std::invalid_argument& e) { ... } – блок обработки исключения при попытке создания дроби с нулевым знаменателем.

- catch (const std::runtime_error& e) { std::cout << "Перехвачено исключение: " << e.what() << "\n"; } – блок обработки исключения при делении на дробь, равную нулю.
