Pazhytniev Dmytro
Лабораторная работа 2:
Используя ключевое слово class, согласно принципам абстракции и инкапсуляции создать тип данных, который содержит несколько конструкторов и деструктор. Каждый конструктор должен создавать объект заданного типа, используя данные другого произвольного типа. Деструктор должен освобождать ресурсы, если они были получены объектом при создании или инициализации.

#include <iostream>
#include <cassert>

class Matrix {
private:
    int rows;
    int cols;
    double** data;

    void allocateMemory() {
        data = new double*[rows];
        for (int i = 0; i < rows; i++) {
            data[i] = new double[cols]();
        }
    }

    void freeMemory() {
        if (data != nullptr) {
            for (int i = 0; i < rows; i++) {
                delete[] data[i];
            }
            delete[] data;
            data = nullptr;
        }
    }

public:
    Matrix() : rows(1), cols(1), data(nullptr) {
        allocateMemory();
        std::cout << "Конструктор по умолчанию: создана матрица 1x1\n";
    }

    Matrix(int r, int c) : rows(r), cols(c), data(nullptr) {
        assert(r > 0 && c > 0);
        allocateMemory();
        std::cout << "Конструктор с параметрами (int, int): создана матрица " << rows << "x" << cols << "\n";
    }

    Matrix(int r, int c, double initValue) : rows(r), cols(c), data(nullptr) {
        assert(r > 0 && c > 0);
        allocateMemory();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                data[i][j] = initValue;
            }
        }
        std::cout << "Конструктор с параметрами (int, int, double): создана матрица " << rows << "x" << cols << "\n";
    }

    Matrix(int r, const double* values) : rows(r), cols(r), data(nullptr) {
        assert(r > 0 && values != nullptr);
        allocateMemory();
        for (int i = 0; i < r; i++) {
            data[i][i] = values[i];
        }
        std::cout << "Конструктор из массива (int, const double*): создана диагональная матрица " << rows << "x" << cols << "\n";
    }

    Matrix(const Matrix& other) : rows(other.rows), cols(other.cols), data(nullptr) {
        allocateMemory();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                data[i][j] = other.data[i][j];
            }
        }
        std::cout << "Конструктор копирования: создана копия матрицы " << rows << "x" << cols << "\n";
    }

    ~Matrix() {
        std::cout << "Деструктор: освобождена память матрицы " << rows << "x" << cols << "\n";
        freeMemory();
    }

    void setElement(int i, int j, double value) {
        assert(i >= 0 && i < rows && j >= 0 && j < cols);
        data[i][j] = value;
    }

    double getElement(int i, int j) const {
        assert(i >= 0 && i < rows && j >= 0 && j < cols);
        return data[i][j];
    }

    int getRows() const { return rows; }
    int getCols() const { return cols; }

    void print() const {
        std::cout << "Матрица " << rows << "x" << cols << ":\n";
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                std::cout << data[i][j] << " ";
            }
            std::cout << "\n";
        }
    }

    Matrix operator+(const Matrix& other) const {
        assert(rows == other.rows && cols == other.cols);
        Matrix result(rows, cols, 0.0);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.data[i][j] = data[i][j] + other.data[i][j];
            }
        }
        return result;
    }
};

int main() {
    std::cout << "Создание объектов разными конструкторами\n\n";

    Matrix m1;
    std::cout << "\n";

    Matrix m2(3, 4);
    m2.setElement(0, 0, 1.5);
    m2.setElement(1, 1, 2.5);
    std::cout << "\n";

    Matrix m3(2, 3, 7.0);
    std::cout << "\n";

    double diagValues[] = {1.0, 2.0, 3.0};
    Matrix m4(3, diagValues);
    std::cout << "\n";

    Matrix m5 = m2;
    std::cout << "\n";

    std::cout << "-----Вывод матриц-----\n";
    std::cout << "Матрица m1:\n";
    m1.print();
    std::cout << "\n";

    std::cout << "Матрица m2 (3x4):\n";
    m2.print();
    std::cout << "\n";

    std::cout << "Матрица m3 (2x3, заполнена 7.0):\n";
    m3.print();
    std::cout << "\n";

    std::cout << "Матрица m4 (диагональная 3x3):\n";
    m4.print();
    std::cout << "\n";

    std::cout << "Матрица m5 (копия m2):\n";
    m5.print();
    std::cout << "\n";

    std::cout << "Операции сложения:\n";
    Matrix m6(2, 2, 1.0);
    Matrix m7(2, 2, 2.0);
    Matrix m8 = m6 + m7;
    std::cout << "Результат сложения m6 + m7:\n";
    m8.print();
    std::cout << "\n";
    return 0;
}


Объяснения:
class Matrix { 
– объявление класса Matrix для работы с двумерными матрицами.

int rows; 
– целочисленная переменная для хранения количества строк матрицы.

int cols; 
– целочисленная переменная для хранения количества столбцов матрицы.

double** data; 
– указатель на указатель типа double для хранения данных матрицы (динамический двумерный массив).

void allocateMemory() { 
– объявление приватного метода для выделения памяти под матрицу.

data = new double*[rows]; 
– выделение памяти под массив указателей (строк матрицы).

data[i] = new double[cols](); 
– выделение памяти для каждой строки матрицы и инициализация элементов нулями ().

void freeMemory() { 
– объявление приватного метода для освобождения памяти, занятой матрицей.

delete[] data[i]; 
– освобождение памяти, занятой i-ой строкой матрицы.

delete[] data; 
– освобождение памяти, занятой массивом указателей на строки.

Matrix() : rows(1), cols(1), data(nullptr) { 
– конструктор по умолчанию. Создает матрицу 1x1.

Matrix(int r, int c) : rows(r), cols(c), data(nullptr) { 
– параметризированный конструктор. Создает матрицу заданного размера, заполненную нулями.

assert(r > 0 && c > 0); 
– проверка с помощью макроса assert: размеры матрицы должны быть положительными.

Matrix(int r, int c, double initValue) : rows(r), cols(c), data(nullptr) { 
– параметризированный конструктор. Создает матрицу заданного размера, заполненную значением initValue.

for (int i = 0; i < rows; i++) { for (int j = 0; j < cols; j++) { data[i][j] = initValue; } } 
– вложенные циклы для инициализации всех элементов матрицы одним значением.

Matrix(int r, const double* values) : rows(r), cols(r), data(nullptr) { 
– параметризированный конструктор. Создает диагональную квадратную матрицу из массива значений.

data[i][i] = values[i]; 
– присваивание элементам главной диагонали значений из переданного массива.

Matrix(const Matrix& other) : rows(other.rows), cols(other.cols), data(nullptr) { 
– конструктор копирования. Создает глубокую копию объекта other.

data[i][j] = other.data[i][j]; 
– поэлементное копирование данных из матрицы other в новую матрицу.

~Matrix() { 
– деструктор. Автоматически вызывается для освобождения ресурсов при удалении объекта.

std::cout << "Деструктор: освобождена память матрицы " << rows << "x" << cols << "\n"; 
– вывод сообщения в деструкторе для демонстрации порядка вызова.

void setElement(int i, int j, double value) { 
– метод для установки значения элемента матрицы по индексам.

double getElement(int i, int j) const { 
– константный метод для получения значения элемента матрицы по индексам.

void print() const { 
– константный метод для вывода матрицы в консоль.

Matrix operator+(const Matrix& other) const { 
– перегрузка оператора + для сложения двух матриц.

assert(rows == other.rows && cols == other.cols); 
– проверка совпадения размеров матриц для операции сложения.

Matrix result(rows, cols, 0.0); 
– создание временной матрицы-результата, заполненной нулями.

result.data[i][j] = data[i][j] + other.data[i][j]; 
– формула поэлементного сложения двух матриц.

Matrix m1; 
– создание объекта m1 с использованием конструктора по умолчанию (матрица 1x1).

Matrix m2(3, 4); 
– создание объекта m2 с использованием параметризированного конструктора (матрица 3x4 нулей).

m2.setElement(0, 0, 1.5); 
– пример использования метода setElement для изменения значения элемента матрицы.

Matrix m3(2, 3, 7.0); 
– создание объекта m3 с использованием конструктора, заполняющего матрицу значением 7.0.

double diagValues[] = {1.0, 2.0, 3.0}; Matrix m4(3, diagValues); 
– создание объекта m4 (диагональной матрицы 3x3) с использованием конструктора из массива.

Matrix m5 = m2; 
– создание объекта m5 с использованием конструктора копирования (копия m2).

m1.print(); 
– пример использования метода print для вывода матрицы в консоль.

Matrix m8 = m6 + m7; 
– пример использования перегруженного оператора + для сложения матриц m6 и m7.