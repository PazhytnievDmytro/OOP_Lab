# Лабораторная работа 6
## Тема: Наследование
### Задание
Необходимо написать код, который иллюстрирует механизм наследования в языке С++. Используя структуры или классы нужно создать иерархию наследования и показать использование ключевых слов public, protected и private в контексте наследования. Также необходимо показать использование множественного наследования, проиллюстрировать потенциальные проблемы, с ним связанные, и способы их решения.

***

## Теоритические сведения по наследству:
### 6.1. Основные понятия наследования
Наследование представляет собой один из ключевых механизмов объектно-ориентированного программирования, позволяющий создавать новые классы на основе существующих. Класс, на основе которого создаётся новый класс, называется базовым классом (base class) или родительским классом. Новый класс называется производным классом (derived class), дочерним классом или подклассом.

Наследование моделирует отношение "является" (is-a), где производный класс представляет собой специализированную версию базового класса. Например, если базовый класс представляет транспортное средство, то производный класс может представлять автомобиль, который является транспортным средством.

Производный класс наследует данные и методы базового класса, но может добавлять новые члены и переопределять унаследованные методы. Это обеспечивает повторное использование кода и позволяет создавать иерархии классов с возрастающей специализацией.

### 6.2. Виды наследования
В языке C++ существует три вида наследования, определяющих преобразование уровней доступа членов базового класса в производном классе.

Открытое наследование (public inheritance) сохраняет уровни доступа членов базового класса: public-члены остаются public, protected-члены остаются protected. Этот вид наследования моделирует отношение "производный класс является базовым классом" и используется чаще всего.

Защищённое наследование (protected inheritance) преобразует public- и protected-члены базового класса в protected-члены производного класса. Это менее распространённый вид наследования, используемый в специфических архитектурных ситуациях.

Закрытое наследование (private inheritance) преобразует все унаследованные члены в private-члены производного класса. В этом случае базовый класс становится частью реализации производного класса, а не его открытым интерфейсом.

### 6.3. Виртуальные функции и полиморфизм
Виртуальные функции обеспечивают механизм динамического полиморфизма, позволяющий вызывать переопределённые методы через указатели и ссылки на базовый класс. Функция объявляется виртуальной с помощью ключевого слова virtual в базовом классе. Переопределённая функция в производном классе может использовать ключевое слово override для явного указания переопределения.

При вызове виртуальной функции через указатель или ссылку на базовый класс выполняется позднее связывание (late binding): конкретная вызываемая версия функции определяется во время выполнения на основе реального типа объекта. Это обеспечивает гибкость кода, позволяя работать с объектами различных производных классов через единый интерфейс базового класса.

### 6.4. Виртуальные деструкторы
Виртуальный деструктор в базовом классе обеспечивает корректное освобождение памяти при удалении объекта производного класса через указатель на базовый класс. Без виртуального деструктора вызывается только деструктор базового класса, что приводит к утечке памяти, выделенной в производном классе.

Правило: если класс имеет виртуальные функции, его деструктор также должен быть виртуальным. Это гарантирует полное и корректное уничтожение объектов любого производного класса.

### 6.5. Множественное наследование
Множественное наследование позволяет производному классу наследовать от нескольких базовых классов одновременно. Синтаксис: class Derived : public Base1, public Base2 { ... }. Это мощный механизм, позволяющий комбинировать функциональность нескольких классов, но он требует осторожности в использовании.

Основные проблемы множественного наследования включают потенциальную неоднозначность при обращении к членам с одинаковыми именами в разных базовых классах, а также проблему ромба (diamond problem) — ситуацию, когда производный класс наследует от двух классов, которые сами наследуют от общего предка.

### 6.6. Проблема ромба
Проблема ромба возникает при множественном наследовании, когда два базовых класса наследуют от общего предка, а производный класс наследует от обоих этих классов. В результате в объекте производного класса оказываются два экземпляра базового класса, что приводит к неоднозначности и дублированию данных.

Решением проблемы ромба является использование виртуального наследования. При объявлении базового класса как виртуального (class Base : virtual public BaseClass) компилятор гарантирует наличие только одного экземпляра виртуального базового класса в объекте производного класса.

    #include <iostream>
    #include <string>
    
    class Vehicle {
    protected:
        std::string brand;
        int year;
        double speed;
    
    public:
        Vehicle() : brand("Unknown"), year(2020), speed(0) {}
        Vehicle(const std::string& b, int y) : brand(b), year(y), speed(0) {}
    
        void accelerate(double amount) {
            speed += amount;
            if (speed > 200) speed = 200;
        }
    
        void brake(double amount) {
            speed -= amount;
            if (speed < 0) speed = 0;
        }
    
        void info() const {
            std::cout << "Марка: " << brand << ", Год: " << year << ", Скорость: " << speed << " км/ч\n";
        }
    
        virtual ~Vehicle() {}
        virtual void move() const {
            std::cout << brand << " движется со скоростью " << speed << " км/ч\n";
        }
    };
    
    class Car : public Vehicle {
    private:
        int doors;
        bool isElectric;
    
    public:
        Car() : Vehicle(), doors(4), isElectric(false) {}
        Car(const std::string& b, int y, int d, bool e) : Vehicle(b, y), doors(d), isElectric(e) {}
    
        void openDoors() const {
            std::cout << "Открытие " << doors << " дверей\n";
        }
    
        void charge() const {
            if (isElectric) {
                std::cout << "Автомобиль заряжается\n";
            } else {
                std::cout << "Этот автомобиль не электрический\n";
            }
        }
    
        void move() const override {
            std::cout << "Автомобиль " << brand << " едет со скоростью " << speed << " км/ч\n";
        }
    };
    
    class Bicycle : protected Vehicle {
    private:
        bool hasBasket;
    
    public:
        Bicycle() : Vehicle(), hasBasket(false) {}
        Bicycle(const std::string& b, int y, bool basket) : Vehicle(b, y), hasBasket(basket) {}
    
        void pedal() {
            accelerate(5);
        }
    
        void ringBell() const {
            std::cout << "Динь динь!\n";
        }
    
        int getYear() const {
            return year;
        }
    
        double getSpeed() const {
            return speed;
        }
    };
    
    class Motorcycle : private Vehicle {
    private:
        int engineCC;
    
    public:
        Motorcycle() : Vehicle(), engineCC(150) {}
        Motorcycle(const std::string& b, int y, int cc) : Vehicle(b, y), engineCC(cc) {}
    
        void wheelie() {
            std::cout << "Выполнение колеса!\n";
        }
    
        std::string getBrand() const {
            return brand;
        }
    
        int getEngineCC() const {
            return engineCC;
        }
    };
    
    class ElectricCar : public Car {
    private:
        int batteryCapacity;
    
    public:
        ElectricCar() : Car(), batteryCapacity(75) {}
        ElectricCar(const std::string& b, int y, int d, int bc) : Car(b, y, d, true), batteryCapacity(bc) {}
    
        void chargeBattery() {
            charge();
            std::cout << "Ёмкость аккумулятора: " << batteryCapacity << " кВт·ч\n";
        }
    
        void move() const override {
            std::cout << "Электромобиль " << brand << " едет бесшумно со скоростью " << speed << " км/ч\n";
        }
    };
    
    class TransportVehicle {
    protected:
        int capacity;
    
    public:
        TransportVehicle() : capacity(0) {}
        TransportVehicle(int c) : capacity(c) {}
    
        virtual void loadCargo() const {
            std::cout << "Загрузка груза с грузоподъёмностью: " << capacity << " кг\n";
        }
    
        virtual ~TransportVehicle() {}
    };
    
    class Truck : public Vehicle, public TransportVehicle {
    private:
        double payload;
    
    public:
        Truck() : Vehicle(), TransportVehicle(), payload(0) {}
        Truck(const std::string& b, int y, int cap, double pay) : Vehicle(b, y), TransportVehicle(cap), payload(pay) {}
    
        void loadCargo() const override {
            std::cout << "Грузовик " << brand << " загружает " << payload << " кг груза\n";
        }
    
        void transport() const {
            std::cout << "Грузовик перевозит груз с грузоподъёмностью " << capacity << " кг\n";
        }
    };
    
    class AmphibiousVehicle : public Car, public TransportVehicle {
    private:
        bool isFloating;
    
    public:
        AmphibiousVehicle() : Car(), TransportVehicle(), isFloating(false) {}
        AmphibiousVehicle(const std::string& b, int y, int d, int cap) : Car(b, y, d, false), TransportVehicle(cap), isFloating(false) {}
    
        void enterWater() {
            isFloating = true;
            speed = 0;
            std::cout << "Транспортное средство переходит в водный режим\n";
        }
    
        void leaveWater() {
            isFloating = false;
            std::cout << "Транспортное средство возвращается в наземный режим\n";
        }
    
        void move() const override {
            if (isFloating) {
                std::cout << "Амфибийное транспортное средство " << brand << " плывёт\n";
            } else {
                Car::move();
            }
        }
    };
    
    class Base1 {
    protected:
        int value1;
    
    public:
        Base1() : value1(10) {}
        void show1() const {
            std::cout << "Base1 значение: " << value1 << "\n";
        }
    };
    
    class Base2 {
    protected:
        int value2;
    
    public:
        Base2() : value2(20) {}
        void show2() const {
            std::cout << "Base2 значение: " << value2 << "\n";
        }
    };
    
    class Derived : public Base1, public Base2 {
    private:
        int result;
    
    public:
        Derived() : Base1(), Base2(), result(value1 + value2) {}
    
        void showAll() const {
            show1();
            show2();
            std::cout << "Результат: " << result << "\n";
        }
    };
    
    class BaseWithVirtual {
    public:
        virtual void show() const {
            std::cout << "BaseWithVirtual::show()\n";
        }
        virtual ~BaseWithVirtual() {}
    };
    
    class Derived1 : public BaseWithVirtual {
    public:
        void show() const override {
            std::cout << "Derived1::show()\n";
        }
    };
    
    class Derived2 : public BaseWithVirtual {
    public:
        void show() const override {
            std::cout << "Derived2::show()\n";
        }
    };
    
    class MostDerived : public Derived1, public Derived2 {
    public:
        void showBoth() const {
            Derived1::show();
            Derived2::show();
        }
    };
    
    class Person {
    protected:
        std::string name;
        int age;
    
    public:
        Person() : name("Unknown"), age(0) {}
        Person(const std::string& n, int a) : name(n), age(a) {}
    
        void introduce() const {
            std::cout << "Человек: " << name << ", Возраст: " << age << "\n";
        }
    
        virtual ~Person() {}
        virtual void work() const {
            std::cout << name << " работает\n";
        }
    };
    
    class Employee : public Person {
    protected:
        double salary;
        std::string department;
    
    public:
        Employee() : Person(), salary(0), department("General") {}
        Employee(const std::string& n, int a, double s, const std::string& d)
            : Person(n, a), salary(s), department(d) {}
    
        void work() const override {
            std::cout << name << " работает в отделе " << department << "\n";
        }
    
        void getSalary() const {
            std::cout << "Зарплата " << name << ": $" << salary << "\n";
        }
    };
    
    class Manager : public Employee {
    private:
        int teamSize;
    
    public:
        Manager() : Employee(), teamSize(0) {}
        Manager(const std::string& n, int a, double s, const std::string& d, int ts)
            : Employee(n, a, s, d), teamSize(ts) {}
    
        void work() const override {
            std::cout << name << " управляет командой из " << teamSize << " человек\n";
        }
    
        void conductMeeting() const {
            std::cout << name << " проводит совещание\n";
        }
    };
    
    int main() {
        std::cout << "Базовый класс Vehicle\n";
        Vehicle v1;
        v1.info();
        v1.accelerate(50);
        v1.move();
        std::cout << "\n";
    
        std::cout << "Открытое наследование: Car : public Vehicle\n";
        Car c1("Toyota", 2022, 4, false);
        c1.info();
        c1.openDoors();
        c1.move();
        std::cout << "\n";
    
        std::cout << "Защищённое наследование: Bicycle : protected Vehicle\n";
        Bicycle b1("Trek", 2021, true);
        b1.pedal();
        b1.pedal();
        std::cout << "Скорость доступна через getter: " << b1.getSpeed() << "\n";
        std::cout << "Год доступен через getter: " << b1.getYear() << "\n";
        std::cout << "\n";
    
        std::cout << "Закрытое наследование: Motorcycle : private Vehicle\n";
        Motorcycle m1("Harley", 2020, 500);
        std::cout << "Марка доступна через getter: " << m1.getBrand() << "\n";
        std::cout << "Объём двигателя доступен через getter: " << m1.getEngineCC() << "\n";
        m1.wheelie();
        std::cout << "\n";
    
        std::cout << "Множественное наследование: Truck : public Vehicle, public TransportVehicle\n";
        Truck t1("Volvo", 2021, 20000, 15000);
        t1.info();
        t1.loadCargo();
        t1.transport();
        std::cout << "\n";
    
        std::cout << "Проблема ромба: AmphibiousVehicle : public Car, public TransportVehicle\n";
        AmphibiousVehicle a1("Amphi", 2022, 4, 500);
        a1.move();
        a1.enterWater();
        a1.move();
        a1.loadCargo();
        std::cout << "\n";
    
        std::cout << "Множественное наследование без виртуального базового класса\n";
        Derived d1;
        d1.showAll();
        std::cout << "\n";
    
        std::cout << "Проблема ромба с несколькими базовыми классами\n";
        MostDerived md1;
        md1.showBoth();
        std::cout << "\n";
    
        std::cout << "Полиморфизм с виртуальными функциями\n";
        BaseWithVirtual* ptr1 = new Derived1();
        BaseWithVirtual* ptr2 = new Derived2();
        ptr1->show();
        ptr2->show();
        delete ptr1;
        delete ptr2;
        std::cout << "\n";
    
        std::cout << "Иерархия наследования: Person -> Employee -> Manager\n";
        Person p1("John", 30);
        p1.introduce();
        p1.work();
    
        Employee e1("Alice", 25, 50000, "IT");
        e1.introduce();
        e1.work();
        e1.getSalary();
    
        Manager m2("Bob", 40, 80000, "Engineering", 10);
        m2.introduce();
        m2.work();
        m2.getSalary();
        m2.conductMeeting();
        std::cout << "\n";
    
        std::cout << "Массив указателей базового класса\n";
        Person* people[] = {&p1, &e1, &m2};
        for (int i = 0; i < 3; ++i) {
            people[i]->work();
        }
        std::cout << "\n";
    
        std::cout << "Операторы приведения в иерархии наследования\n";
        Employee* empPtr = &e1;
        std::cout << "Employee является Person: " << (dynamic_cast<Person*>(empPtr) != nullptr ? "да" : "нет") << "\n";
    
        Manager* manPtr = dynamic_cast<Manager*>(empPtr);
        if (manPtr == nullptr) {
            std::cout << "Employee не является Manager (dynamic_cast не удался)\n";
        }
        std::cout << "\n";
        return 0;
    }
    



protected: - спецификатор доступа, члены доступны в классе и его производных классах, но недоступны извне

std::string brand; - защищённая переменная для хранения марки транспортного средства

double speed; - защищённая переменная для хранения текущей скорости

public: - спецификатор доступа, члены доступны из любой части программы

Vehicle() : brand("Unknown"), year(2020), speed(0) {} - конструктор по умолчанию базового класса

Vehicle(const std::string& b, int y) : brand(b), year(y), speed(0) {} - конструктор с параметрами

void accelerate(double amount) { ... } - метод для увеличения скорости

void brake(double amount) { ... } - метод для уменьшения скорости

void info() const { ... } - константный метод для вывода информации о транспортном средстве

virtual void move() const { ... } - виртуальная функция для переопределения в производных классах

virtual ~Vehicle() {} - виртуальный деструктор для корректного освобождения памяти через указатель базового класса

class Car : public Vehicle { ... } - открытое наследование от базового класса Vehicle

Car() : Vehicle(), doors(4), isElectric(false) {} - конструктор по умолчанию с вызовом конструктора базового класса

Car(const std::string& b, int y, int d, bool e) : Vehicle(b, y), doors(d), isElectric(e) {} - конструктор с параметрами

void openDoors() const { ... } - метод для открытия дверей

void charge() const { ... } - метод для зарядки электромобиля

void move() const override { ... } - переопределение виртуальной функции с ключевым словом override

class Bicycle : protected Vehicle { ... } - защищённое наследование от Vehicle

void pedal() { accelerate(5); } - метод для увеличения скорости через педалирование

void ringBell() const { ... } - метод для звонка

int getYear() const { return year; } - метод для доступа к защищённому полю year

double getSpeed() const { return speed; } - метод для доступа к защищённому полю speed

class Motorcycle : private Vehicle { ... } - закрытое наследование от Vehicle

std::string getBrand() const { return brand; } - метод для доступа к полю brand через getter

int getEngineCC() const { return engineCC; } - метод для доступа к полю engineCC

void wheelie() { ... } - метод для выполнения трюка "колесо"

class ElectricCar : public Car { ... } - открытое наследование от Car

void chargeBattery() { ... } - метод для зарядки аккумулятора

void move() const override { ... } - переопределение виртуальной функции

class TransportVehicle { ... } - отдельный базовый класс для транспортных средств с грузоподъёмностью

virtual void loadCargo() const { ... } - виртуальная функция для загрузки груза

virtual ~TransportVehicle() {} - виртуальный деструктор

class Truck : public Vehicle, public TransportVehicle { ... } - множественное наследование от двух базовых классов

void loadCargo() const override { ... } - переопределение виртуальной функции

void transport() const { ... } - метод для транспортировки груза

class AmphibiousVehicle : public Car, public TransportVehicle { ... } - множественное наследование, демонстрирующее проблему ромба

void move() const override { ... } - переопределение виртуальной функции

class Base1 { ... } - первый базовый класс для демонстрации множественного наследования

void show1() const { ... } - метод для вывода значения

class Base2 { ... } - второй базовый класс для демонстрации множественного наследования

void show2() const { ... } - метод для вывода значения

class Derived : public Base1, public Base2 { ... } - производный класс с множественным наследованием

int result; - результат суммирования

void showAll() const { ... } - метод для вывода всех значений

class BaseWithVirtual { ... } - базовый класс с виртуальными функциями

class Derived1 : public BaseWithVirtual { ... } - первый производный класс

void show() const override { ... } - переопределение виртуальной функции

class Derived2 : public BaseWithVirtual { ... } - второй производный класс

void show() const override { ... } - переопределение виртуальной функции

class MostDerived : public Derived1, public Derived2 { ... } - производный класс с двумя путями к базовому классу

void showBoth() const { ... } - метод для вызова обеих версий show()

class Person { ... } - базовый класс для иерархии "Человек -> Сотрудник -> Менеджер"

Person() : name("Unknown"), age(0) {} - конструктор по умолчанию

Person(const std::string& n, int a) : name(n), age(a) {} - конструктор с параметрами

void introduce() const { ... } - метод для представления

virtual void work() const { ... } - виртуальная функция для работы

virtual ~Person() {} - виртуальный деструктор

class Employee : public Person { ... } - производный класс Сотрудник

Employee() : Person(), salary(0), department("General") {} - конструктор по умолчанию

Employee(const std::string& n, int a, double s, const std::string& d) : Person(n, a), salary(s), department(d) {}

void work() const override { ... } - переопределение виртуальной функции

void getSalary() const { ... } - метод для получения информации о зарплате

class Manager : public Employee { ... } - производный класс Менеджер

Manager() : Employee(), teamSize(0) {} - конструктор по умолчанию

Manager(const std::string& n, int a, double s, const std::string& d, int ts) : Employee(n, a, s, d), teamSize(ts) {}

void work() const override { ... } - переопределение виртуальной функции

void conductMeeting() const { ... } - метод для проведения совещания

dynamic_cast<Person*>(empPtr) - оператор динамического приведения типов в иерархии наследования


dynamic_cast<Manager*>(empPtr) - попытка привести указатель Employee к Manager





