# Лабораторная работа 3
## Перегрузка функций, методов, операторов
### Задание
Необходимо написать код, который иллюстрирует принципы перегрузки функций, методов и операторов в языке С++. Перегрузка функции обозначает наличие в программе нескольких функций с одним и тем же именем, но разными списками аргументов. Перегрузка методов означает то же самое, но в рамках какого-то класса. Перегрузка операторов соединяет два предыдущих принципа. 

---

## Теоритические сведения
### 3.1. Перегрузка функций
Перегрузка функций (function overloading) — это возможность определять несколько функций с одним именем, но разными списками параметров. Компилятор выбирает нужную функцию на основе количества и типов аргументов, переданных при вызове. Это позволяет создавать функции, выполняющие схожие операции над данными разных типов, используя одно и то же имя.

При вызове перегруженной функции компилятор выполняет разрешение перегрузки (overload resolution), которое включает следующие этапы: определение кандидатов (функции с именем, соответствующим вызову), отбор жизнеспособных функций (функции, которые могут быть вызваны с данными аргументами), и выбор лучшей жизнеспособной функции на основе преобразований типов аргументов.

Важно отметить, что тип возвращаемого значения не учитывается при разрешении перегрузки. Две функции с одинаковыми параметрами, но разными типами возврата не могут быть перегружены — это приведёт к ошибке компиляции.

### 3.2. Перегрузка методов
Перегрузка методов работает аналогично перегрузке функций, но в контексте классов. Методы класса могут быть перегружены другими методами того же класса, а также наследоваться и перегружаться в производных классах. Перегрузка методов позволяет классам предоставлять различные способы выполнения схожих операций.

При вызове перегруженного метода компилятор учитывает не только типы параметров, но и контекст вызова (через объект какого типа вызывается метод). Это позволяет иметь методы с одинаковыми именами, но разными реализациями в разных классах иерархии наследования.

### 3.3. Перегрузка операторов
Перегрузка операторов (operator overloading) позволяет определять собственную реализацию стандартных операторов для пользовательских типов данных. Это делает код более читаемым и естественным, позволяя использовать привычный синтаксис выражений с объектами пользовательских типов.

Операторы перегружаются посредством определения функций с ключевым словом operator, за которым следует символ оператора. Существует два способа перегрузки: как методы класса (левой операнд является объектом класса) и как обычные функции (оба операнда передаются как параметры). Некоторые операторы (например, operator=) могут быть перегружены только как методы класса, в то время как другие (например, operator<<) чаще перегружаются как дружественные функции или обычные функции.

Не все операторы могут быть перегружены. К ним относятся: оператор разрешения области видимости (::), оператор выбора члена (.), оператор указателя на член (.*), тернарный оператор (?:) и оператор sizeof. Остальные операторы могут быть перегружены, но следует делать это осторожно, сохраняя интуитивно понятную семантику оператора.

---

## Код программы
    #include <iostream>
    #include <cmath>
    
    class Vector {
    private:
        double x;
        double y;
    
    public:
        Vector() : x(0), y(0) {}
        Vector(double x, double y) : x(x), y(y) {}
    
        double getX() const { return x; }
        double getY() const { return y; }
    
        void setX(double val) { x = val; }
        void setY(double val) { y = val; }
    
        double length() const {
            return std::sqrt(x * x + y * y);
        }
    
        Vector add(const Vector& other) const {
            return Vector(x + other.x, y + other.y);
        }
    
        Vector add(double scalar) const {
            return Vector(x + scalar, y + scalar);
        }
    
        Vector multiply(double scalar) const {
            return Vector(x * scalar, y * scalar);
        }
    
        double dot(const Vector& other) const {
            return x * other.x + y * other.y;
        }
    
        Vector operator+(const Vector& other) const {
            return add(other);
        }
    
        Vector operator+(double scalar) const {
            return add(scalar);
        }
    
        Vector operator-(const Vector& other) const {
            return Vector(x - other.x, y - other.y);
        }
    
        Vector operator*(double scalar) const {
            return multiply(scalar);
        }
    
        double operator*(const Vector& other) const {
            return dot(other);
        }
    
        bool operator==(const Vector& other) const {
            return x == other.x && y == other.y;
        }
    
        bool operator!=(const Vector& other) const {
            return !(*this == other);
        }
    
        Vector operator-() const {
            return Vector(-x, -y);
        }
    
        double operator[](int index) const {
            if (index == 0) return x;
            if (index == 1) return y;
            return 0;
        }
    
        void print() const {
            std::cout << "(" << x << ", " << y << ")";
        }
    };
    
    Vector createVector(double x, double y) {
        return Vector(x, y);
    }
    
    Vector createVector(double value) {
        return Vector(value, value);
    }
    
    Vector createVector(const Vector& v) {
        return Vector(v.getX(), v.getY());
    }
    
    void printVector(const Vector& v) {
        std::cout << "Вектор: ";
        v.print();
        std::cout << ", длина: " << v.length() << std::endl;
    }
    
    void printVectorInfo(const Vector& v, const std::string& name) {
        std::cout << name << ": ";
        v.print();
        std::cout << std::endl;
    }
    
    int main() {
        std::cout << "Создание векторов разными конструкторами\n";
        Vector v1;
        Vector v2(3, 4);
        Vector v3(5, -2);
    
        printVector(v1);
        printVector(v2);
        printVector(v3);
    
        std::cout << "\nСоздание векторов перегруженными функциями\n";
        Vector v4 = createVector(7, 1);
        Vector v5 = createVector(2.5);
        Vector v6 = createVector(v2);
    
        printVector(v4);
        printVector(v5);
        printVector(v6);
    
        std::cout << "\nПерегрузка методов:add\n";
        Vector v7 = v2.add(v3);
        Vector v8 = v2.add(10.0);
    
        std::cout << "v2.add(v3): ";
        v7.print();
        std::cout << std::endl;
    
        std::cout << "v2.add(10.0): ";
        v8.print();
        std::cout << std::endl;
    
        std::cout << "\nПерегрузка операторов\n";
        Vector v9 = v2 + v3;
        Vector v10 = v2 + 5.0;
        Vector v11 = v2 - v3;
        Vector v12 = v2 * 3.0;
        double dotProduct = v2 * v3;
    
        std::cout << "v2 + v3: ";
        v9.print();
        std::cout << std::endl;
    
        std::cout << "v2 + 5.0: ";
        v10.print();
        std::cout << std::endl;
    
        std::cout << "v2 - v3: ";
        v11.print();
        std::cout << std::endl;
    
        std::cout << "v2 * 3.0: ";
        v12.print();
        std::cout << std::endl;
    
        std::cout << "v2 * v3 (скалярное произведение): " << dotProduct << std::endl;
    
        std::cout << "\nОператоры сравнения\n";
        Vector v13(3, 4);
        Vector v14(3, 4);
        Vector v15(1, 2);
    
        std::cout << "v13 == v14: " << (v13 == v14 ? "true" : "false") << std::endl;
        std::cout << "v13 == v2: " << (v13 == v2 ? "true" : "false") << std::endl;
        std::cout << "v13 != v15: " << (v13 != v15 ? "true" : "false") << std::endl;
    
        std::cout << "\nУнарные операторы\n";
        Vector v16 = -v2;
        std::cout << "-v2: ";
        v16.print();
        std::cout << std::endl;
    
        std::cout << "\nПерегрузка оператора []\n";
        std::cout << "v2[0] = " << v2[0] << std::endl;
        std::cout << "v2[1] = " << v2[1] << std::endl;
    
        std::cout << "\nПерегруженные функции вывода\n";
        printVectorInfo(v2, "v2");
        printVectorInfo(v3, "v3");
        return 0;
    }

## Объяснения
- class Vector { – объявление класса Vector для работы с двумерными векторами

- double x; – вещественная переменная для хранения координаты X вектора

- double y; – вещественная переменная для хранения координаты Y вектора

- Vector() : x(0), y(0) {} – конструктор по умолчанию. Создает нулевой вектор (0, 0)

- Vector(double x, double y) : x(x), y(y) {} – параметризированный конструктор. Создает вектор с заданными координатами

- double length() const { return std::sqrt(x * x + y * y); } – метод для вычисления длины (модуля) вектора

- Vector add(const Vector& other) const { return Vector(x + other.x, y + other.y); } – метод для сложения двух векторов

- Vector add(double scalar) const { return Vector(x + scalar, y + scalar); } – перегруженный метод add для сложения вектора со скаляром (скаляр прибавляется к каждой координате)

- Vector multiply(double scalar) const { return Vector(x * scalar, y * scalar); } – метод для умножения вектора на скаляр

- double dot(const Vector& other) const { return x * other.x + y * other.y; } – метод для вычисления скалярного произведения двух векторов

- Vector operator+(const Vector& other) const { return add(other); } – перегрузка бинарного оператора + для сложения двух векторов

- Vector operator+(double scalar) const { return add(scalar); } – перегрузка бинарного оператора + для сложения вектора и скаляра

- Vector operator-(const Vector& other) const { return Vector(x - other.x, y - other.y); } – перегрузка бинарного оператора - для вычитания векторов

- Vector operator*(double scalar) const { return multiply(scalar); } – перегрузка бинарного оператора * для умножения вектора на скаляр

- double operator*(const Vector& other) const { return dot(other); } – перегрузка бинарного оператора * для вычисления скалярного произведения векторов

- bool operator==(const Vector& other) const { return x == other.x && y == other.y; } – перегрузка оператора сравнения на равенство ==

- bool operator!=(const Vector& other) const { return !(*this == other); } – перегрузка оператора сравнения на неравенство !=

- Vector operator-() const { return Vector(-x, -y); } – перегрузка унарного оператора - для получения противоположного вектора

- double operator[](int index) const { – перегрузка оператора индексации [] для доступа к координатам вектора по индексу (0 для X, 1 для Y)

- if (index == 0) return x; if (index == 1) return y; – реализация доступа к координатам внутри перегруженного оператора []

- void print() const { std::cout << "(" << x << ", " << y << ")"; } – метод для вывода вектора в формате (x, y)

- Vector createVector(double x, double y) { return Vector(x, y); } – функция для создания вектора по двум координатам

- Vector createVector(double value) { return Vector(value, value); } – перегруженная функция createVector для создания вектора с одинаковыми координатами (value, value)

- Vector createVector(const Vector& v) { return Vector(v.getX(), v.getY()); } – перегруженная функция createVector для создания копии вектора

- void printVector(const Vector& v) { – функция для вывода вектора и его длины

- void printVectorInfo(const Vector& v, const std::string& name) { – перегруженная функция для вывода вектора с указанием его имени

- Vector v1; – создание вектора v1 с помощью конструктора по умолчанию (0, 0)

- Vector v2(3, 4); – создание вектора v2 с помощью параметризированного конструктора (3, 4)

- Vector v4 = createVector(7, 1); – создание вектора с помощью функции createVector с двумя аргументами

- Vector v5 = createVector(2.5); – создание вектора с помощью перегруженной функции createVector с одним аргументом (2.5, 2.5)

- Vector v6 = createVector(v2); – создание вектора (копии v2) с помощью перегруженной функции createVector, принимающей вектор

- Vector v7 = v2.add(v3); – пример использования метода add для сложения двух векторов

- Vector v8 = v2.add(10.0); – пример использования перегруженного метода add для сложения вектора и скаляра

- Vector v9 = v2 + v3; – пример использования перегруженного оператора + для сложения векторов

- Vector v10 = v2 + 5.0; – пример использования перегруженного оператора + для сложения вектора и скаляра

- double dotProduct = v2 * v3; – пример использования перегруженного оператора * для вычисления скалярного произведения

- std::cout << "v13 == v14: " << (v13 == v14 ? "true" : "false") << std::endl; – пример использования перегруженного оператора сравнения ==

- Vector v16 = -v2; – пример использования перегруженного унарного оператора -

- std::cout << "v2[0] = " << v2[0] << std::endl; – пример использования перегруженного оператора индексации [] для доступа к координате X
