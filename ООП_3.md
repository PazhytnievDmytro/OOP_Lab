Лабораторная работа 3
Перегрузка функций, методов, операторов

#include <iostream>
#include <cmath>

class Vector {
private:
    double x;
    double y;

public:
    Vector() : x(0), y(0) {}
    Vector(double x, double y) : x(x), y(y) {}

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double val) { x = val; }
    void setY(double val) { y = val; }

    double length() const {
        return std::sqrt(x * x + y * y);
    }

    Vector add(const Vector& other) const {
        return Vector(x + other.x, y + other.y);
    }

    Vector add(double scalar) const {
        return Vector(x + scalar, y + scalar);
    }

    Vector multiply(double scalar) const {
        return Vector(x * scalar, y * scalar);
    }

    double dot(const Vector& other) const {
        return x * other.x + y * other.y;
    }

    Vector operator+(const Vector& other) const {
        return add(other);
    }

    Vector operator+(double scalar) const {
        return add(scalar);
    }

    Vector operator-(const Vector& other) const {
        return Vector(x - other.x, y - other.y);
    }

    Vector operator*(double scalar) const {
        return multiply(scalar);
    }

    double operator*(const Vector& other) const {
        return dot(other);
    }

    bool operator==(const Vector& other) const {
        return x == other.x && y == other.y;
    }

    bool operator!=(const Vector& other) const {
        return !(*this == other);
    }

    Vector operator-() const {
        return Vector(-x, -y);
    }

    double operator[](int index) const {
        if (index == 0) return x;
        if (index == 1) return y;
        return 0;
    }

    void print() const {
        std::cout << "(" << x << ", " << y << ")";
    }
};

Vector createVector(double x, double y) {
    return Vector(x, y);
}

Vector createVector(double value) {
    return Vector(value, value);
}

Vector createVector(const Vector& v) {
    return Vector(v.getX(), v.getY());
}

void printVector(const Vector& v) {
    std::cout << "Вектор: ";
    v.print();
    std::cout << ", длина: " << v.length() << std::endl;
}

void printVectorInfo(const Vector& v, const std::string& name) {
    std::cout << name << ": ";
    v.print();
    std::cout << std::endl;
}

int main() {
    std::cout << "Создание векторов разными конструкторами\n";
    Vector v1;
    Vector v2(3, 4);
    Vector v3(5, -2);

    printVector(v1);
    printVector(v2);
    printVector(v3);

    std::cout << "\nСоздание векторов перегруженными функциями\n";
    Vector v4 = createVector(7, 1);
    Vector v5 = createVector(2.5);
    Vector v6 = createVector(v2);

    printVector(v4);
    printVector(v5);
    printVector(v6);

    std::cout << "\nПерегрузка методов:add\n";
    Vector v7 = v2.add(v3);
    Vector v8 = v2.add(10.0);

    std::cout << "v2.add(v3): ";
    v7.print();
    std::cout << std::endl;

    std::cout << "v2.add(10.0): ";
    v8.print();
    std::cout << std::endl;

    std::cout << "\nПерегрузка операторов\n";
    Vector v9 = v2 + v3;
    Vector v10 = v2 + 5.0;
    Vector v11 = v2 - v3;
    Vector v12 = v2 * 3.0;
    double dotProduct = v2 * v3;

    std::cout << "v2 + v3: ";
    v9.print();
    std::cout << std::endl;

    std::cout << "v2 + 5.0: ";
    v10.print();
    std::cout << std::endl;

    std::cout << "v2 - v3: ";
    v11.print();
    std::cout << std::endl;

    std::cout << "v2 * 3.0: ";
    v12.print();
    std::cout << std::endl;

    std::cout << "v2 * v3 (скалярное произведение): " << dotProduct << std::endl;

    std::cout << "\nОператоры сравнения\n";
    Vector v13(3, 4);
    Vector v14(3, 4);
    Vector v15(1, 2);

    std::cout << "v13 == v14: " << (v13 == v14 ? "true" : "false") << std::endl;
    std::cout << "v13 == v2: " << (v13 == v2 ? "true" : "false") << std::endl;
    std::cout << "v13 != v15: " << (v13 != v15 ? "true" : "false") << std::endl;

    std::cout << "\nУнарные операторы\n";
    Vector v16 = -v2;
    std::cout << "-v2: ";
    v16.print();
    std::cout << std::endl;

    std::cout << "\nПерегрузка оператора []\n";
    std::cout << "v2[0] = " << v2[0] << std::endl;
    std::cout << "v2[1] = " << v2[1] << std::endl;

    std::cout << "\nПерегруженные функции вывода\n";
    printVectorInfo(v2, "v2");
    printVectorInfo(v3, "v3");
    return 0;
}


class Vector { – объявление класса Vector для работы с двумерными векторами

double x; – вещественная переменная для хранения координаты X вектора

double y; – вещественная переменная для хранения координаты Y вектора

Vector() : x(0), y(0) {} – конструктор по умолчанию. Создает нулевой вектор (0, 0)

Vector(double x, double y) : x(x), y(y) {} – параметризированный конструктор. Создает вектор с заданными координатами

double length() const { return std::sqrt(x * x + y * y); } – метод для вычисления длины (модуля) вектора

Vector add(const Vector& other) const { return Vector(x + other.x, y + other.y); } – метод для сложения двух векторов

Vector add(double scalar) const { return Vector(x + scalar, y + scalar); } – перегруженный метод add для сложения вектора со скаляром (скаляр прибавляется к каждой координате)

Vector multiply(double scalar) const { return Vector(x * scalar, y * scalar); } – метод для умножения вектора на скаляр

double dot(const Vector& other) const { return x * other.x + y * other.y; } – метод для вычисления скалярного произведения двух векторов

Vector operator+(const Vector& other) const { return add(other); } – перегрузка бинарного оператора + для сложения двух векторов

Vector operator+(double scalar) const { return add(scalar); } – перегрузка бинарного оператора + для сложения вектора и скаляра

Vector operator-(const Vector& other) const { return Vector(x - other.x, y - other.y); } – перегрузка бинарного оператора - для вычитания векторов

Vector operator*(double scalar) const { return multiply(scalar); } – перегрузка бинарного оператора * для умножения вектора на скаляр

double operator*(const Vector& other) const { return dot(other); } – перегрузка бинарного оператора * для вычисления скалярного произведения векторов

bool operator==(const Vector& other) const { return x == other.x && y == other.y; } – перегрузка оператора сравнения на равенство ==

bool operator!=(const Vector& other) const { return !(*this == other); } – перегрузка оператора сравнения на неравенство !=

Vector operator-() const { return Vector(-x, -y); } – перегрузка унарного оператора - для получения противоположного вектора

double operator[](int index) const { – перегрузка оператора индексации [] для доступа к координатам вектора по индексу (0 для X, 1 для Y)

if (index == 0) return x; if (index == 1) return y; – реализация доступа к координатам внутри перегруженного оператора []

void print() const { std::cout << "(" << x << ", " << y << ")"; } – метод для вывода вектора в формате (x, y)

Vector createVector(double x, double y) { return Vector(x, y); } – функция для создания вектора по двум координатам

Vector createVector(double value) { return Vector(value, value); } – перегруженная функция createVector для создания вектора с одинаковыми координатами (value, value)

Vector createVector(const Vector& v) { return Vector(v.getX(), v.getY()); } – перегруженная функция createVector для создания копии вектора

void printVector(const Vector& v) { – функция для вывода вектора и его длины

void printVectorInfo(const Vector& v, const std::string& name) { – перегруженная функция для вывода вектора с указанием его имени

Vector v1; – создание вектора v1 с помощью конструктора по умолчанию (0, 0)

Vector v2(3, 4); – создание вектора v2 с помощью параметризированного конструктора (3, 4)

Vector v4 = createVector(7, 1); – создание вектора с помощью функции createVector с двумя аргументами

Vector v5 = createVector(2.5); – создание вектора с помощью перегруженной функции createVector с одним аргументом (2.5, 2.5)

Vector v6 = createVector(v2); – создание вектора (копии v2) с помощью перегруженной функции createVector, принимающей вектор

Vector v7 = v2.add(v3); – пример использования метода add для сложения двух векторов

Vector v8 = v2.add(10.0); – пример использования перегруженного метода add для сложения вектора и скаляра

Vector v9 = v2 + v3; – пример использования перегруженного оператора + для сложения векторов

Vector v10 = v2 + 5.0; – пример использования перегруженного оператора + для сложения вектора и скаляра

double dotProduct = v2 * v3; – пример использования перегруженного оператора * для вычисления скалярного произведения

std::cout << "v13 == v14: " << (v13 == v14 ? "true" : "false") << std::endl; – пример использования перегруженного оператора сравнения ==

Vector v16 = -v2; – пример использования перегруженного унарного оператора -

std::cout << "v2[0] = " << v2[0] << std::endl; – пример использования перегруженного оператора индексации [] для доступа к координате X

printVectorInfo(v2, "v2"); – пример использования перегруженной функции printVectorInfo