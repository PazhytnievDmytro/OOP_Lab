Лабораторная работа 7
Обработка ошибок, исключения
Задание: необходимо написать код, который иллюстрирует использование исключений для обработки исключительных ситуаций. Используя ключевые слова throw, try и catch, нужно обработать несколько разных ислючений. Также нужно показать эффект исключений разных типов в рамках одного блока try-catch и восстановление программы после обработки исключения.

Далее нужно создать свой тип исключений -- так, чтобы его обработка гармонично сочеталась с обработкой встроенных типов ислючений.

Код:
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>
#include <memory>
#include <cmath>
#include <functional>

class MathException : public std::runtime_error {
private:
    std::string operation;
    double operand1;
    double operand2;

public:
    MathException(const std::string& msg, const std::string& op, double a, double b)
        : std::runtime_error(msg), operation(op), operand1(a), operand2(b) {}

    const std::string& getOperation() const { return operation; }
    double getOperand1() const { return operand1; }
    double getOperand2() const { return operand2; }

    void printDetails() const {
        std::cout << "Операция: " << operation << "\n";
        std::cout << "Первый операнд: " << operand1 << "\n";
        std::cout << "Второй операнд: " << operand2 << "\n";
    }
};

class DatabaseException : public std::exception {
private:
    std::string message;
    int errorCode;
    std::string tableName;

public:
    DatabaseException(const std::string& msg, int code, const std::string& table)
        : message(msg), errorCode(code), tableName(table) {}

    const char* what() const noexcept override {
        return message.c_str();
    }

    int getErrorCode() const { return errorCode; }
    const std::string& getTableName() const { return tableName; }
};

class ValidationException : public std::exception {
private:
    std::string fieldName;
    std::string invalidValue;

public:
    ValidationException(const std::string& field, const std::string& value)
        : fieldName(field), invalidValue(value) {}

    const char* what() const noexcept override {
        static std::string msg;
        msg = "Ошибка валидации поля '" + fieldName + "': недопустимое значение '" + invalidValue + "'";
        return msg.c_str();
    }

    const std::string& getFieldName() const { return fieldName; }
    const std::string& getInvalidValue() const { return invalidValue; }
};

double divide(double a, double b) {
    if (b == 0) {
        throw std::invalid_argument("Деление на ноль: делитель не может быть равен нулю");
    }
    return a / b;
}

double squareRoot(double value) {
    if (value < 0) {
        throw std::domain_error("Извлечение корня из отрицательного числа");
    }
    return std::sqrt(value);
}

int factorial(int n) {
    if (n < 0) {
        throw std::invalid_argument("Факториал отрицательного числа не определён");
    }
    if (n > 20) {
        throw std::overflow_error("Факториал слишком большой, произойдёт переполнение");
    }
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}

int arrayAccess(const std::vector<int>& arr, int index) {
    if (index < 0 || index >= static_cast<int>(arr.size())) {
        throw std::out_of_range("Индекс выходит за пределы массива");
    }
    return arr[index];
}

void validateUserInput(const std::string& name, int age, const std::string& email) {
    if (name.empty()) {
        throw ValidationException("name", "пустая строка");
    }
    if (age < 0 || age > 150) {
        throw ValidationException("age", std::to_string(age));
    }
    if (email.find('@') == std::string::npos) {
        throw ValidationException("email", email);
    }
}

void connectToDatabase(const std::string& connectionString) {
    if (connectionString.empty()) {
        throw DatabaseException("Пустая строка подключения", 1001, "N/A");
    }
    if (connectionString.length() < 10) {
        throw DatabaseException("Слишком короткая строка подключения", 1002, "N/A");
    }
}

void performComplexCalculation(double x, double y, const std::string& operation) {
    try {
        if (operation == "divide") {
            double result = divide(x, y);
            std::cout << "Результат деления: " << result << "\n";
        }
        else if (operation == "sqrt") {
            double result = squareRoot(x);
            std::cout << "Квадратный корень: " << result << "\n";
        }
        else if (operation == "factorial") {
            int result = factorial(static_cast<int>(x));
            std::cout << "Факториал: " << result << "\n";
        }
        else {
            throw std::invalid_argument("Неизвестная операция: " + operation);
        }
    }
    catch (const std::invalid_argument& e) {
        std::cout << "Перехвачено std::invalid_argument: " << e.what() << "\n";
        throw MathException("Ошибка в математической операции", operation, x, y);
    }
    catch (const std::domain_error& e) {
        std::cout << "Перехвачено std::domain_error: " << e.what() << "\n";
        throw MathException("Ошибка области определения", operation, x, y);
    }
    catch (const std::overflow_error& e) {
        std::cout << "Перехвачено std::overflow_error: " << e.what() << "\n";
        throw MathException("Ошибка переполнения", operation, x, y);
    }
}

void processDataWithRecovery() {
    static int attemptCount = 0;
    attemptCount++;

    std::vector<int> data = {1, 2, 3, 4, 5};

    try {
        std::cout << "\nПопытка " << attemptCount << " обработки данных:\n";
        int value = arrayAccess(data, 10);
        std::cout << "Значение: " << value << "\n";
    }
    catch (const std::out_of_range& e) {
        std::cout << "Исключение перехвачено: " << e.what() << "\n";
        std::cout << "Восстановление: используется значение по умолчанию\n";
        std::cout << "Программа продолжает работу после обработки исключения\n";
    }
}

void demonstrateMultipleExceptionTypes() {
    std::cout << "\nДемонстрация разных типов исключений в одном блоке try-catch:\n";

    std::cout << "\nТест 1: Деление на ноль\n";
    try {
        divide(10, 0);
    }
    catch (const std::invalid_argument& e) {
        std::cout << "  -> std::invalid_argument: " << e.what() << "\n";
    }
    catch (const std::exception& e) {
        std::cout << "  -> std::exception: " << e.what() << "\n";
    }

    std::cout << "\nТест 2: Корень из отрицательного\n";
    try {
        squareRoot(-5);
    }
    catch (const std::domain_error& e) {
        std::cout << "  -> std::domain_error: " << e.what() << "\n";
    }
    catch (const std::exception& e) {
        std::cout << "  -> std::exception: " << e.what() << "\n";
    }

    std::cout << "\nТест 3: Факториал отрицательного\n";
    try {
        factorial(-3);
    }
    catch (const std::invalid_argument& e) {
        std::cout << "  -> std::invalid_argument: " << e.what() << "\n";
    }
    catch (const std::exception& e) {
        std::cout << "  -> std::exception: " << e.what() << "\n";
    }

    std::cout << "\nТест 4: Индекс за пределами массива\n";
    try {
        std::vector<int> arr = {1, 2, 3};
        arrayAccess(arr, 10);
    }
    catch (const std::out_of_range& e) {
        std::cout << "  -> std::out_of_range: " << e.what() << "\n";
    }
    catch (const std::exception& e) {
        std::cout << "  -> std::exception: " << e.what() << "\n";
    }
}

void demonstrateCustomExceptions() {
    std::cout << "\nДемонстрация пользовательских типов исключений:\n";

    try {
        throw MathException("Ошибка вычисления", "division", 42.0, 0.0);
    }
    catch (const MathException& e) {
        std::cout << "Перехвачено MathException: " << e.what() << "\n";
        e.printDetails();
    }

    std::cout << "\n";
    try {
        throw DatabaseException("Ошибка подключения к базе данных", 1001, "users");
    }
    catch (const DatabaseException& e) {
        std::cout << "Перехвачено DatabaseException\n";
        std::cout << "  Код ошибки: " << e.getErrorCode() << "\n";
        std::cout << "  Таблица: " << e.getTableName() << "\n";
    }

    std::cout << "\n";
    try {
        throw ValidationException("age", "200");
    }
    catch (const ValidationException& e) {
        std::cout << "Перехвачено ValidationException: " << e.what() << "\n";
    }
}

void demonstrateExceptionHandling() {
    std::cout << "\nДемонстрация восстановления после исключения:\n";

    double values[] = {16.0, 4.0, 0.0, -4.0, 9.0};

    for (int i = 0; i < 5; ++i) {
        try {
            std::cout << "\nОбработка значения " << values[i] << ":\n";
            double result = squareRoot(values[i]);
            std::cout << "  Квадратный корень: " << result << "\n";
        }
        catch (const std::domain_error& e) {
            std::cout << "  Исключение: " << e.what() << "\n";
            std::cout << "  Пропуск этого значения, продолжение обработки...\n";
        }
    }
}

void demonstrateStackUnwinding() {
    std::cout << "\nДемонстрация раскрутки стека (stack unwinding):\n";

    struct Resource {
        std::string resName;
        Resource(const std::string& n) : resName(n) {
            std::cout << "Создание ресурса: " << resName << "\n";
        }
        ~Resource() {
            std::cout << "Освобождение ресурса: " << resName << "\n";
        }
    };

    try {
        Resource r1("ресурс_1");
        std::cout << "Генерация исключения...\n";
        throw std::runtime_error("Тестовое исключение");
        Resource r2("ресурс_2");
    }
    catch (const std::exception& e) {
        std::cout << "Исключение перехвачено: " << e.what() << "\n";
    }
    std::cout << "Программа продолжает работу после блока try-catch\n";
}

void demonstrateRethrow() {
    std::cout << "\nДемонстрация повторного выброса исключения:\n";

    try {
        try {
            throw std::runtime_error("Внутреннее исключение");
        }
        catch (...) {
            std::cout << "Повторный выброс исключения...\n";
            throw;
        }
    }
    catch (const std::exception& e) {
        std::cout << "Внешний перехват: " << e.what() << "\n";
    }
}

void demonstrateTryCatchMultiple() {
    std::cout << "\nДемонстрация нескольких блоков catch:\n";

    std::cout << "\nТест: Деление на ноль\n";
    try {
        divide(100, 0);
    }
    catch (const MathException& e) {
        std::cout << "  MathException: " << e.what() << "\n";
        std::cout << "  Операция: " << e.getOperation() << "\n";
    }
    catch (const std::invalid_argument& e) {
        std::cout << "  std::invalid_argument: " << e.what() << "\n";
    }
    catch (const std::overflow_error& e) {
        std::cout << "  std::overflow_error: " << e.what() << "\n";
    }
    catch (...) {
        std::cout << "  Неизвестное исключение\n";
    }

    std::cout << "\nТест: Факториал > 20\n";
    try {
        factorial(25);
    }
    catch (const MathException& e) {
        std::cout << "  MathException: " << e.what() << "\n";
        std::cout << "  Операция: " << e.getOperation() << "\n";
    }
    catch (const std::invalid_argument& e) {
        std::cout << "  std::invalid_argument: " << e.what() << "\n";
    }
    catch (const std::overflow_error& e) {
        std::cout << "  std::overflow_error: " << e.what() << "\n";
    }
    catch (...) {
        std::cout << "  Неизвестное исключение\n";
    }

    std::cout << "\nТест: Недопустимая операция\n";
    try {
        performComplexCalculation(5, 5, "unknown");
    }
    catch (const MathException& e) {
        std::cout << "  MathException: " << e.what() << "\n";
        std::cout << "  Операция: " << e.getOperation() << "\n";
    }
    catch (const std::invalid_argument& e) {
        std::cout << "  std::invalid_argument: " << e.what() << "\n";
    }
    catch (const std::overflow_error& e) {
        std::cout << "  std::overflow_error: " << e.what() << "\n";
    }
    catch (...) {
        std::cout << "  Неизвестное исключение\n";
    }
}

int main() {
    std::cout << "Лабораторная работа 7: Обработка ошибок, исключения\n\n";

    std::cout << "Базовые исключения стандартной библиотеки\n";
    double divResult = divide(10, 2);
    std::cout << "10 / 2 = " << divResult << "\n";

    try {
        divide(10, 0);
    }
    catch (const std::invalid_argument& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    try {
        squareRoot(-5);
    }
    catch (const std::domain_error& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    try {
        factorial(-5);
    }
    catch (const std::invalid_argument& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    try {
        factorial(25);
    }
    catch (const std::overflow_error& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    std::cout << "\nВалидация входных данных\n";
    try {
        validateUserInput("", 25, "test@email.com");
    }
    catch (const ValidationException& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    try {
        validateUserInput("John", 200, "test@email.com");
    }
    catch (const ValidationException& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    try {
        validateUserInput("John", 25, "invalid-email");
    }
    catch (const ValidationException& e) {
        std::cout << "Исключение: " << e.what() << "\n";
    }

    demonstrateMultipleExceptionTypes();

    demonstrateCustomExceptions();

    demonstrateExceptionHandling();

    demonstrateStackUnwinding();

    demonstrateRethrow();

    demonstrateTryCatchMultiple();

    for (int i = 0; i < 3; ++i) {
        processDataWithRecovery();
    }

    std::cout << "\nВсе демонстрации завершены\n";

    return 0;
}


Ключевые слова:
throw - генерация исключения
try - начало блока, где могут возникать исключения
catch - перехват и обработка исключения

Стандартные типы исключений:
std::invalid_argument - некорректные аргументы функции
std::domain_error - ошибка области определения
std::overflow_error - переполнение
std::out_of_range - выход за пределы диапазона
std::runtime_error - общая ошибка времени выполнения

Пользовательские типы исключений:
MathException - для математических операций
DatabaseException - для ошибок базы данных
ValidationException - для ошибок валидации

Особенности:
Множественные блоки catch для разных типов исключений
Иерархия исключений (наследование от std::exception)
Раскрутка стека (stack unwinding) - автоматический вызов деструкторов
Повторный выброс исключения (rethrow)
Восстановление программы после обработки исключения
Инкапсуляция дополнительной информации в пользовательских исключениях



class MathException : public std::runtime_error { ... } - пользовательский класс исключения, наследующий от std::runtime_error

private: - закрытая секция класса

std::string operation; - поле для хранения названия операции

double operand1; - поле для хранения первого операнда

double operand2; - поле для хранения второго операнда

public: - открытая секция класса

MathException(const std::string& msg, const std::string& op, double a, double b) - конструктор с параметрами

: std::runtime_error(msg), operation(op), operand1(a), operand2(b) {} - список инициализации, вызов конструктора базового класса

const std::string& getOperation() const { return operation; } - метод для получения названия операции

double getOperand1() const { return operand1; } - метод для получения первого операнда

double getOperand2() const { return operand2; } - метод для получения второго операнда

void printDetails() const { ... } - метод для вывода деталей исключения

class DatabaseException : public std::exception { ... } - пользовательский класс исключения для ошибок базы данных

private: - закрытая секция

std::string message; - текст сообщения об ошибке

int errorCode; - код ошибки

std::string tableName; - имя таблицы

public: - открытая секция

DatabaseException(const std::string& msg, int code, const std::string& table) - конструктор

const char* what() const noexcept override { ... } - переопределение метода what()

int getErrorCode() const { return errorCode; } - метод для получения кода ошибки

const std::string& getTableName() const { return tableName; } - метод для получения имени таблицы

class ValidationException : public std::exception { ... } - пользовательский класс исключения для ошибок валидации

private: - закрытая секция

std::string fieldName; - имя поля

std::string invalidValue; - недопустимое значение

public: - открытая секция

ValidationException(const std::string& field, const std::string& value) - конструктор

const char* what() const noexcept override { ... } - переопределение метода what()

double divide(double a, double b) { ... } - функция деления двух чисел

if (b == 0) { throw std::invalid_argument("Деление на ноль..."); } - проверка делителя на ноль, выброс исключения

return a / b; - возврат результата деления

double squareRoot(double value) { ... } - функция вычисления квадратного корня

if (value < 0) { throw std::domain_error("Извлечение корня..."); } - проверка на отрицательное значение

return std::sqrt(value); - возврат квадратного корня

int factorial(int n) { ... } - функция вычисления факториала

if (n < 0) { throw std::invalid_argument("Факториал отрицательного..."); } - проверка на отрицательное число

if (n > 20) { throw std::overflow_error("Факториал слишком большой..."); } - проверка на переполнение

int arrayAccess(const std::vector& arr, int index) { ... } - функция доступа к элементу массива

if (index < 0 || index >= static_cast(arr.size())) { throw std::out_of_range("Индекс выходит..."); } - проверка индекса

void validateUserInput(...) { ... } - функция валидации входных данных

if (name.empty()) { throw ValidationException("name", "пустая строка"); } - проверка имени

if (age < 0 || age > 150) { throw ValidationException("age", ...); } - проверка возраста

if (email.find('@') == std::string::npos) { throw ValidationException("email", email); } - проверка email

void performComplexCalculation(double x, double y, const std::string& operation) { ... } - функция с вложенными try-catch

catch (const std::invalid_argument& e) { ... throw MathException(...); } - перехват и повторный выброс

void processDataWithRecovery() { ... } - функция демонстрации восстановления после исключения

catch (const std::out_of_range& e) { ... std::cout << "Программа продолжает работу..."; } - обработка и восстановление

void demonstrateMultipleExceptionTypes() { ... } - демонстрация разных типов исключений в одном блоке

catch (const std::invalid_argument& e) { ... } - перехват invalid_argument

catch (const std::domain_error& e) { ... } - перехват domain_error

catch (const std::out_of_range& e) { ... } - перехват out_of_range

catch (const std::exception& e) { ... } - перехват базового класса exception

void demonstrateStackUnwinding() { ... } - демонстрация раскрутки стека

try { Resource r1("ресурс_1"); throw std::runtime_error(...); Resource r2(...); } - создание объектов

catch (const std::exception& e) { ... } - перехват исключения

~Resource() { std::cout << "Освобождение ресурса: " << name; } - деструктор освобождает ресурс

void demonstrateRethrow() { ... } - демонстрация повторного выброса исключения

throw; - повторный выброс текущего исключения

throw std::invalid_argument("Сообщение"); - генерация исключения с текстом ошибки

try { ... } catch (const std::invalid_argument& e) { ... } - блок try-catch для перехвата

catch (...) { ... } - перехват любых исключений




