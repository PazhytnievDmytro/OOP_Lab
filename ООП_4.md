# Лабораторная работа 4
## Стандартные алгоритмы С++
### Задание
Необходимо написать программу, иллюстрирующую правильное использование функций из стандартной библиотеки алгоритмов

---

## Теоритические сведения
### 4.1. Обзор стандартной библиотеки алгоритмов
Стандартная библиотека алгоритмов (STL Algorithms) представляет собой набор шаблонных функций, предназначенных для работы с контейнерами и последовательностями элементов. Эти алгоритмы реализуют типовые операции обработки данных: поиск, сортировку, преобразование, подсчёт и многие другие. Использование стандартных алгоритмов вместо ручной реализации повышает надёжность кода, его переносимость и производительность.

Все алгоритмы STL работают через итераторный интерфейс, что обеспечивает их универсальность и возможность применения к различным контейнерам STL и пользовательским контейнерам с поддержкой итераторов. Алгоритмы не зависят от конкретного типа элементов и могут работать с любыми типами, для которых определены необходимые операции (сравнение, присваивание и т.д.).

### 4.2. Категории стандартных алгоритмов
Алгоритмы не изменения (non-modifying algorithms) выполняют операции чтения данных без их модификации. К ним относятся: std::all_of, std::any_of, std::none_of (проверка условий), std::count, std::count_if (подсчёт), std::find, std::find_if (поиск), std::equal (сравнение), std::mismatch (поиск первого несовпадения).

Алгоритмы изменения (modifying algorithms) модифицируют элементы последовательности или перемещают их между контейнерами. К ним относятся: std::copy, std::copy_if (копирование), std::move (перемещение), std::transform (преобразование), std::replace, std::replace_if (замена), std::remove, std::remove_if (удаление), std::fill, std::fill_n (заполнение), std::generate, std::generate_n (генерация).

Алгоритмы сортировки и упорядочения обеспечивают упорядочение элементов. К ним относятся: std::sort (полная сортировка), std::stable_sort (стабильная сортировка), std::partial_sort (частичная сортировка), std::nth_element (частичная сортировка для поиска n-го элемента), std::is_sorted (проверка упорядоченности).

Алгоритмы поиска в упорядоченных последовательностях: std::binary_search (бинарный поиск), std::lower_bound, std::upper_bound, std::equal_range (границы диапазона).

Числовые алгоритмы (из заголовочного файла ): std::accumulate (суммирование), std::inner_product (скалярное произведение), std::partial_sum, std::adjacent_difference.

### 4.3. Использование предикатов и лямбда-выражений
Большинство алгоритмов STL принимают в качестве параметров функции-предикаты, определяющие условия выполнения операций. Предикат — это функция или объект-функция, возвращающий bool. С момента стандарта C++11 широкое распространение получили лямбда-выражения, позволяющие определять предикаты непосредственно в месте вызова алгоритма.

Лямбда-выражение имеет следующий синтаксис: [capture list] (parameters) -> return_type { body }. Список захвата (capture list) определяет, какие переменные из внешней области видимости доступны внутри лямбда-выражения. Захват по значению ([x]) копирует переменную, захват по ссылке ([&x]) создаёт ссылку на переменную.

---

## Код программы
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <numeric>
    #include <iterator>
    #include <functional>
    #include <random>
    
    void printCollection(const std::string& title, const std::vector<int>& v) {
        std::cout << title << ": ";
        std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
        std::cout << "\n";
    }
    
    int main() {
        std::vector<int> v1(10, 2);
        printCollection("Исходный вектор v1", v1);
    
        bool allEven = std::all_of(v1.begin(), v1.end(), [](int i) { return i % 2 == 0; });
        std::cout << "std::all_of (все четные): " << (allEven ? "true" : "false") << "\n\n";
    
        bool anyNegative = std::any_of(v1.begin(), v1.end(), [](int i) { return i < 0; });
        std::cout << "std::any_of (есть отрицательные): " << (anyNegative ? "true" : "false") << "\n\n";
    
        bool noneZero = std::none_of(v1.begin(), v1.end(), [](int i) { return i == 0; });
        std::cout << "std::none_of (нет нулей): " << (noneZero ? "true" : "false") << "\n\n";
    
        std::vector<int> v2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        printCollection("Вектор v2 для демонстрации алгоритмов", v2);
    
        int countEven = std::count(v2.begin(), v2.end(), 2);
        std::cout << "std::count (кол-во двоек): " << countEven << "\n";
    
        int countIfOdd = std::count_if(v2.begin(), v2.end(), [](int i) { return i % 2 != 0; });
        std::cout << "std::count_if (кол-во нечетных): " << countIfOdd << "\n\n";
    
        std::vector<int>::iterator it = std::find(v2.begin(), v2.end(), 5);
        if (it != v2.end()) {
            std::cout << "std::find (позиция 5): " << std::distance(v2.begin(), it) << "\n";
        }
    
        it = std::find_if(v2.begin(), v2.end(), [](int i) { return i > 7; });
        if (it != v2.end()) {
            std::cout << "std::find_if (первый элемент > 7): " << *it << "\n\n";
        }
    
        int sum = std::accumulate(v2.begin(), v2.end(), 0);
        std::cout << "std::accumulate (сумма элементов): " << sum << "\n";
    
        int product = std::accumulate(v2.begin(), v2.end(), 1, std::multiplies<int>());
        std::cout << "std::accumulate с умножением (произведение): " << product << "\n\n";
    
        std::vector<int> v3(10);
        std::fill(v3.begin(), v3.end(), 7);
        printCollection("std::fill (заполнить семерками)", v3);
    
        std::vector<int> v4(10);
        std::fill_n(v4.begin(), 5, 3);
        printCollection("std::fill_n (заполнить 5 элементов тройками)", v4);
    
        std::vector<int> v5 = {1, 2, 3, 4, 5};
        printCollection("Вектор v5 до std::for_each", v5);
        std::for_each(v5.begin(), v5.end(), [](int& i) { i *= 2; });
        printCollection("std::for_each (умножить на 2)", v5);
    
        std::vector<int> v6 = {1, 2, 3, 4, 5};
        std::vector<int> v7(5);
        std::transform(v6.begin(), v6.end(), v7.begin(), [](int i) { return i * i; });
        printCollection("std::transform (возвести в квадрат)", v7);
    
        std::vector<int> v8 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        std::vector<int> v9(5);
        std::copy(v8.begin(), v8.begin() + 5, v9.begin());
        printCollection("std::copy (первые 5 элементов)", v9);
    
        std::vector<int> v10 = {10, 20, 30, 40, 50};
        std::vector<int> v11(5);
        std::copy_if(v8.begin(), v8.end(), v11.begin(), [](int i) { return i % 2 == 0; });
        printCollection("std::copy_if (четные элементы)", v11);
    
        std::vector<int> v12 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        printCollection("Вектор v12 до сортировки", v12);
        std::sort(v12.begin(), v12.end());
        printCollection("std::sort (после сортировки по возрастанию)", v12);
    
        std::sort(v12.begin(), v12.end(), std::greater<int>());
        printCollection("std::sort с greater (по убыванию)", v12);
    
        std::vector<int> v13 = {5, 3, 8, 1, 2};
        printCollection("Вектор v13 (частичный набор)", v13);
        std::partial_sort(v13.begin(), v13.begin() + 3, v13.end());
        printCollection("std::partial_sort (первые 3 элемента - наименьшие)", v13);
    
        std::vector<int> v14 = {3, 1, 4, 1, 5, 9, 2, 6};
        auto minIt = std::min_element(v14.begin(), v14.end());
        auto maxIt = std::max_element(v14.begin(), v14.end());
        std::cout << "std::min_element: " << *minIt << "\n";
        std::cout << "std::max_element: " << *maxIt << "\n\n";
    
        std::vector<int> v15 = {1, 2, 3, 4, 5, 4, 3, 2, 1};
        std::cout << "Вектор v15: ";
        std::copy(v15.begin(), v15.end(), std::ostream_iterator<int>(std::cout, " "));
        std::cout << "\n";
    
        auto range = std::equal_range(v15.begin(), v15.end(), 3);
        std::cout << "std::equal_range для значения 3: ";
        for (auto it = range.first; it != range.second; ++it) {
            std::cout << *it << " ";
        }
        std::cout << "\n\n";
    
        std::vector<int> v16 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        std::vector<int> v17(10);
        std::vector<int> v18(10);
        std::vector<int>::iterator mid = std::copy(v16.begin(), v16.end(), v17.begin());
        std::copy(v16.begin(), v16.end(), v18.begin());
        printCollection("std::copy (дублирование вектора)", v17);
    
        std::swap(v17, v18);
        printCollection("std::swap (обмен содержимого)", v17);
        printCollection("После swap, v18:", v18);
    
        std::vector<int> v19 = {1, 2, 3, 0, 4, 5, 0, 6};
        printCollection("Вектор v19 с нулями", v19);
        auto newEnd = std::remove(v19.begin(), v19.end(), 0);
        v19.erase(newEnd, v19.end());
        printCollection("std::remove (удалить нули)", v19);
    
        std::vector<int> v20 = {1, 2, 3, 4, 5};
        printCollection("Вектор v20", v20);
        std::replace(v20.begin(), v20.end(), 3, 99);
        printCollection("std::replace (заменить 3 на 99)", v20);
    
        std::vector<int> v21 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        std::vector<int> v22;
        std::vector<int> v23;
        std::partition(v21.begin(), v21.end(), [](int i) { return i % 2 == 0; });
        printCollection("std::partition (четные в начало)", v21);
    
        std::vector<int> v24 = {1, 2, 3, 4, 5};
        bool isSorted = std::is_sorted(v24.begin(), v24.end());
        std::cout << "std::is_sorted (отсортирован ли v24): " << (isSorted ? "true" : "false") << "\n\n";
    
        std::vector<int> v25(10);
        std::iota(v25.begin(), v25.end(), 100);
        printCollection("std::iota (последовательность от 100)", v25);
    
        std::vector<int> v26 = {1, 2, 3, 4, 5};
        std::vector<int> v27 = {1, 2, 3, 4, 5};
        std::vector<int> v28 = {1, 2, 3, 4, 5};
        bool equal1 = std::equal(v26.begin(), v26.end(), v27.begin());
        std::cout << "std::equal (v26 == v27): " << (equal1 ? "true" : "false") << "\n";
        v27[2] = 99;
        bool equal2 = std::equal(v26.begin(), v26.end(), v27.begin());
        std::cout << "std::equal (v26 == v27 после изменения): " << (equal2 ? "true" : "false") << "\n\n";
        return 0;
    }

## Объяснение всех уникальных и важных строк в программе

- void printCollection(const std::string& title, const std::vector<int>& v) { – функция для печати содержимого вектора с заголовком

- std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " ")); – использование алгоритма std::copy для вывода элементов вектора в поток std::cout через итератор вывода std::ostream_iterator

- bool allEven = std::all_of(v1.begin(), v1.end(), [](int i) { return i % 2 == 0; }); – использование алгоритма std::all_of с лямбда-выражением для проверки, все ли элементы вектора четные

- bool anyNegative = std::any_of(v1.begin(), v1.end(), [](int i) { return i < 0; }); – использование алгоритма std::any_of для проверки, есть ли в векторе хотя бы один отрицательный элемент

- bool noneZero = std::none_of(v1.begin(), v1.end(), [](int i) { return i == 0; }); – использование алгоритма std::none_of для проверки, что в векторе нет ни одного элемента, равного нулю

- int countEven = std::count(v2.begin(), v2.end(), 2); – использование алгоритма std::count для подсчета количества элементов, равных 2

- int countIfOdd = std::count_if(v2.begin(), v2.end(), [](int i) { return i % 2 != 0; }); – использование алгоритма std::count_if с лямбда-выражением для подсчета количества нечетных элементов

- std::vector<int>::iterator it = std::find(v2.begin(), v2.end(), 5); – использование алгоритма std::find для поиска первого элемента, равного 5. Возвращает итератор

- it = std::find_if(v2.begin(), v2.end(), [](int i) { return i > 7; }); – использование алгоритма std::find_if для поиска первого элемента, удовлетворяющего условию (больше 7)

- int sum = std::accumulate(v2.begin(), v2.end(), 0); – использование алгоритма std::accumulate для вычисления суммы всех элементов вектора

- int product = std::accumulate(v2.begin(), v2.end(), 1, std::multiplies<int>()); – использование алгоритма std::accumulate с бинарной операцией для вычисления произведения всех элементов вектора

- std::fill(v3.begin(), v3.end(), 7); – использование алгоритма std::fill для заполнения всего диапазона вектора v3 значением 7

- std::fill_n(v4.begin(), 5, 3); – использование алгоритма std::fill_n для заполнения первых 5 элементов вектора v4 значением 3

- std::for_each(v5.begin(), v5.end(), [](int& i) { i *= 2; }); – использование алгоритма std::for_each с лямбда-выражением, изменяющим каждый элемент вектора 

- std::transform(v6.begin(), v6.end(), v7.begin(), [](int i) { return i * i; }); – использование алгоритма std::transform для применения функции к каждому элементу v6 и записи результата в v7

- std::copy(v8.begin(), v8.begin() + 5, v9.begin()); – использование алгоритма std::copy для копирования первых 5 элементов из v8 в v9

- std::copy_if(v8.begin(), v8.end(), v11.begin(), [](int i) { return i % 2 == 0; }); – использование алгоритма std::copy_if для копирования только тех элементов из v8, которые удовлетворяют условию, в v11

- std::sort(v12.begin(), v12.end()); – использование алгоритма std::sort для сортировки вектора v12 по возрастанию

- std::sort(v12.begin(), v12.end(), std::greater<int>()); – использование алгоритма std::sort с пользовательским компаратором std::greater для сортировки вектора v12 по убыванию

- std::partial_sort(v13.begin(), v13.begin() + 3, v13.end()); – использование алгоритма std::partial_sort для частичной сортировки: первые 3 позиции в векторе v13 будут содержать три наименьших элемента в отсортированном порядке

- auto minIt = std::min_element(v14.begin(), v14.end()); – использование алгоритма std::min_element для поиска минимального элемента в векторе. Возвращает итератор на него

- auto maxIt = std::max_element(v14.begin(), v14.end()); – использование алгоритма std::max_element для поиска максимального элемента в векторе. Возвращает итератор на него

- auto range = std::equal_range(v15.begin(), v15.end(), 3); – использование алгоритма std::equal_range для поиска диапазона элементов, равных 3, в отсортированном векторе v15. Возвращает пару итераторов

- std::swap(v17, v18); – использование алгоритма std::swap для обмена содержимым двух векторов v17 и v18

- auto newEnd = std::remove(v19.begin(), v19.end(), 0); – использование алгоритма std::remove для перемещения в конец всех элементов, равных 0. Возвращает итератор на новый логический конец контейнера

- v19.erase(newEnd, v19.end()); – использование метода вектора erase в сочетании с std::remove для физического удаления лишних элементов из вектора

- std::replace(v20.begin(), v20.end(), 3, 99); – использование алгоритма std::replace для замены всех элементов, равных 3, на значение 99

- std::partition(v21.begin(), v21.end(), [](int i) { return i % 2 == 0; }); – использование алгоритма std::partition для переупорядочивания элементов вектора v21 так, чтобы все четные элементы оказались в начале, а нечетные - в конце

- bool isSorted = std::is_sorted(v24.begin(), v24.end()); – использование алгоритма std::is_sorted для проверки, отсортирован ли вектор v24 по неубыванию

- std::iota(v25.begin(), v25.end(), 100); – использование алгоритма std::iota для заполнения вектора v25 последовательно возрастающими значениями, начиная со 100

- bool equal1 = std::equal(v26.begin(), v26.end(), v27.begin()); – использование алгоритма std::equal для поэлементного сравнения двух диапазонов (векторов v26 и v27)


