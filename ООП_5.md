# Лабораторная работа 5
## Обобщенное программирование, шаблоны функций, статический полиморфизм
### Задание
Необходимо написать код, который иллюстрирует использование шаблонов в языке С++. С помощью ключевых слов auto и template нужно написать обобщенные функции, которые принимают диапазоны любой длины, объекты любого типа, произвольное количество аргументов.

---

## Теоритические сведения
### 5.1. Концепция обобщённого программирования
Обобщённое программирование (generic programming) — это парадигма программирования, ориентированная на разработку алгоритмов и структур данных, которые могут работать с различными типами данных. Основная идея заключается в отделении алгоритма от конкретных типов данных, что позволяет создавать универсальный код, применимый к широкому кругу задач.

В языке C++ основным механизмом обобщённого программирования являются шаблоны (templates). Шаблоны позволяют определять классы и функции, параметризованные типами данных, и генерировать конкретные версии кода для каждого используемого типа во время компиляции. Это обеспечивает статический полиморфизм — выбор конкретной реализации определяется на этапе компиляции, а не во время выполнения.

### 5.2. Шаблоны функций
Шаблон функции определяет семейство функций, которые работают с различными типами данных. Синтаксис шаблона функции включает список параметров шаблона, заключённый в угловые скобки: template или template. Параметр шаблона T представляет собой имя типа, которое будет подставлено компилятором при конкретизации шаблона.

При вызове функции с конкретными аргументами компилятор выполняет вывод аргументов шаблона (template argument deduction) — определяет, какой тип следует подставить вместо параметра T. Если вывод типов невозможен или требуется явно указать тип, это можно сделать явно: function(arguments).

Шаблоны функций могут иметь несколько параметров шаблона: template<typename T1, typename T2>. Также можно определять шаблоны с параметрами-значениями (например, template<typename T, std::size_t N>).

### 5.3. Шаблоны классов
Шаблон класса определяет семейство классов, которые различаются типами своих членов или значениями параметров-констант. Синтаксис аналогичен шаблонам функций: template class MyClass { ... }. При создании объекта шаблонного класса необходимо указать конкретный тип: MyClass obj;.

Шаблоны классов могут иметь статические члены, которые существуют отдельно для каждого конкретизированного типа. Это позволяет создавать данные, общие для всех объектов одного типа, но различные для объектов разных типов.

### 5.4. Вариадические шаблоны
Вариадические шаблоны (variadic templates) позволяют определять функции и классы с произвольным количеством параметров различных типов. Пакет параметров (parameter pack) обозначается как Args... и может содержать любое количество аргументов, включая ноль. Распаковка пакета выполняется с помощью оператора ... после имени пакета.

Рекурсивная обработка пакетов параметров осуществляется через разделение пакета на первый элемент и оставшуюся часть. На каждом шаге рекурсии обрабатывается первый элемент, а рекурсивный вызов получает оставшийся пакет. Базовый случай рекурсии обрабатывает ситуацию, когда пакет пуст.

### 5.5. Выражения свертки
Выражения свертки (fold expressions), введённые в C++17, предоставляют компактный синтаксис для применения бинарного оператора ко всем элементам пакета параметров. Синтаксис: (expr op ...) для унарной свертки слева направо, (... op expr) для унарной свертки справа налево, (expr op ... op expr) для бинарной свертки.

Выражения свертки существенно упрощают работу с вариадическими шаблонами, позволяя избежать ручной рекурсии для многих типичных задач.

### 5.6. Статический полиморфизм
Статический полиморфизм достигается через механизм шаблонов и разрешается во время компиляции. В отличие от динамического полиморфизма (виртуальные функции), статический полиморфизм не имеет накладных расходов на этапе выполнения, но требует полного определения типов на этапе компиляции.

Основные преимущества статического полиморфизма: отсутствие накладных расходов на виртуальные вызовы, возможность работы с типами, не имеющими общего базового класса, и более широкие возможности оптимизации компилятором.

---

## Код программы
    #include <iostream>
    #include <vector>
    #include <list>
    #include <deque>
    #include <array>
    #include <type_traits>
    #include <string>
    #include <sstream>
    
    template<typename T>
    T maximumValue(T a, T b) {
        return (a > b) ? a : b;
    }
    
    template<typename T1, typename T2>
    auto maximumValue(T1 a, T2 b) {
        return (a > b) ? a : b;
    }
    
    template<typename Container>
    void printContainer(const Container& container) {
        for (const auto& elem : container) {
            std::cout << elem << " ";
        }
        std::cout << "\n";
    }
    
    template<typename Iterator>
    void printRange(Iterator begin, Iterator end) {
        for (auto it = begin; it != end; ++it) {
            std::cout << *it << " ";
        }
        std::cout << "\n";
    }
    
    template<typename T, std::size_t N>
    void printArray(const T (&arr)[N]) {
        for (std::size_t i = 0; i < N; ++i) {
            std::cout << arr[i] << " ";
        }
        std::cout << "\n";
    }
    
    template<typename T>
    auto sumRange(T begin, T end) {
        auto total = typename std::remove_reference<decltype(*begin)>::type{};
        for (auto it = begin; it != end; ++it) {
            total += *it;
        }
        return total;
    }
    
    template<typename T>
    class DataContainer {
    private:
        T data;
    public:
        DataContainer() : data(T{}) {}
        DataContainer(T value) : data(value) {}
        T getData() const { return data; }
        void setData(T value) { data = value; }
    };
    
    template<typename T>
    struct Point {
        T x;
        T y;
        Point() : x(T{}), y(T{}) {}
        Point(T xVal, T yVal) : x(xVal), y(yVal) {}
    };
    
    template<typename T>
    T calculateSum(T first) {
        return first;
    }
    
    template<typename T, typename... Args>
    T calculateSum(T first, Args... rest) {
        return first + calculateSum(rest...);
    }
    
    template<typename... Args>
    void printValues(Args... args) {
        ((std::cout << args << " "), ...);
        std::cout << "\n";
    }
    
    template<typename T, typename... Args>
    bool allEqual(T first, Args... rest) {
        return ((first == rest) && ...);
    }
    
    template<typename... Args>
    auto multiplyAll(Args... args) {
        return (args * ...);
    }
    
    template<template<typename, typename...> class Container, typename T, typename... Args>
    Container<T> makeContainer(Args... args) {
        Container<T> c;
        ((c.insert(c.end(), args)), ...);
        return c;
    }
    
    template<std::size_t N, typename T>
    constexpr T arraySumImpl(const std::array<T, N>& arr, std::size_t idx) {
        if (idx >= N) return T{};
        return arr[idx] + arraySumImpl(arr, idx + 1);
    }
    
    template<std::size_t N, typename T>
    constexpr T arraySum(const std::array<T, N>& arr) {
        return arraySumImpl(arr, 0);
    }
    
    template<typename T>
    void reversePrint(T begin, T end) {
        if (begin == end) return;
        --end;
        std::cout << *end << " ";
        reversePrint(begin, end);
    }
    
    template<typename T>
    class Calculator {
    public:
        T add(T a, T b) { return a + b; }
        T subtract(T a, T b) { return a - b; }
        T multiply(T a, T b) { return a * b; }
        T divide(T a, T b) { return a / b; }
    };
    
    template<>
    class Calculator<std::string> {
    public:
        std::string add(std::string a, std::string b) { return a + b; }
        std::string subtract(std::string a, std::string) { return a; }
        std::string multiply(std::string, std::string) { return ""; }
        std::string divide(std::string, std::string) { return ""; }
    };
    
    template<typename T>
    T identity(T value) {
        return value;
    }
    
    template<typename T>
    auto square(T value) -> decltype(value * value) {
        return value * value;
    }
    
    int main() {
        std::cout << "Шаблоны функций: maximumValue\n";
        std::cout << "max(5, 3): " << maximumValue(5, 3) << "\n";
        std::cout << "max(3.14, 2.71): " << maximumValue(3.14, 2.71) << "\n";
        std::cout << "max('a', 'z'): " << maximumValue('a', 'z') << "\n";
        std::cout << "max(5, 3.14): " << maximumValue(5, 3.14) << "\n\n";
    
        std::cout << "auto и вывод типов\n";
        auto x = 42;
        auto y = 3.14159;
        auto z = x + y;
        std::cout << "auto x = 42: " << x << "\n";
        std::cout << "auto y = 3.14159: " << y << "\n";
        std::cout << "auto z = x + y: " << z << "\n";
        auto lambda = [](int n) { return n * 2; };
        std::cout << "auto lambda(10): " << lambda(10) << "\n\n";
    
        std::cout << "Шаблоны для контейнеров\n";
        std::vector<int> v = {1, 2, 3, 4, 5};
        std::list<std::string> lst = {"one", "two", "three"};
        std::deque<double> dq = {1.1, 2.2, 3.3};
    
        printContainer(v);
        printContainer(lst);
        printContainer(dq);
    
        std::cout << "\nprintRange с итераторами\n";
        printRange(v.begin(), v.end());
        printRange(dq.begin(), dq.end());
    
        std::cout << "\nprintArray для встроенных массивов\n";
        int arr[] = {10, 20, 30, 40, 50};
        printArray(arr);
        double arr2[] = {1.1, 2.2, 3.3};
        printArray(arr2);
    
        std::cout << "\nsumRange с автоматическим выводом\n";
        std::vector<int> v2 = {1, 2, 3, 4, 5};
        std::cout << "Сумма вектора: " << sumRange(v2.begin(), v2.end()) << "\n";
    
        std::cout << "\nКласс-шаблон DataContainer\n";
        DataContainer<int> ic(42);
        DataContainer<std::string> sc("Hello");
        std::cout << "DataContainer<int>: " << ic.getData() << "\n";
        std::cout << "DataContainer<string>: " << sc.getData() << "\n";
    
        std::cout << "\nСтруктура-шаблон Point\n";
        Point<int> p1(10, 20);
        Point<double> p2(3.5, 7.2);
        std::cout << "Point<int>: (" << p1.x << ", " << p1.y << ")\n";
        std::cout << "Point<double>: (" << p2.x << ", " << p2.y << ")\n";
    
        std::cout << "\nВариадические шаблоны: calculateSum\n";
        std::cout << "sum(1, 2, 3, 4, 5): " << calculateSum(1, 2, 3, 4, 5) << "\n";
        std::cout << "sum(1.5, 2.5, 3.0): " << calculateSum(1.5, 2.5, 3.0) << "\n";
        std::cout << "sum(10): " << calculateSum(10) << "\n";
    
        std::cout << "\nВариадическая функция printValues\n";
        printValues(1, 2.5, "hello", 'a');
        printValues(100, 200, 300);
    
        std::cout << "\nallEqual с fold expression\n";
        std::cout << "allEqual(5, 5, 5): " << (allEqual(5, 5, 5) ? "true" : "false") << "\n";
        std::cout << "allEqual(5, 5, 6): " << (allEqual(5, 5, 6) ? "true" : "false") << "\n";
        std::cout << "allEqual(1): " << (allEqual(1) ? "true" : "false") << "\n";
    
        std::cout << "\nmultiplyAll с fold expression\n";
        std::cout << "multiplyAll(2, 3, 4): " << multiplyAll(2, 3, 4) << "\n";
        std::cout << "multiplyAll(1.5, 2): " << multiplyAll(1.5, 2) << "\n";
    
        std::cout << "\nmakeContainer с параметрическим шаблоном\n";
        auto vec = makeContainer<std::vector, int>(1, 2, 3, 4, 5);
        printContainer(vec);
        auto lst2 = makeContainer<std::list, int>(10, 20, 30);
        printContainer(lst2);
    
        std::cout << "\nconstexpr с if constexpr\n";
        std::array<int, 5> arr3 = {1, 2, 3, 4, 5};
        std::cout << "Сумма массива: " << arraySum(arr3) << "\n";
        std::array<int, 0> emptyArr;
        std::cout << "Сумма пустого массива: " << arraySum(emptyArr) << "\n";
    
        std::cout << "\nreversePrint (рекурсивный шаблон)\n";
        std::vector<int> v3 = {1, 2, 3, 4, 5};
        std::cout << "Обратный вывод: ";
        reversePrint(v3.begin(), v3.end());
        std::cout << "\n";
    
        std::cout << "\nСпециализация шаблона класса\n";
        Calculator<int> ci;
        Calculator<std::string> cs;
        std::cout << "Calculator<int>(5 + 3): " << ci.add(5, 3) << "\n";
        std::cout << "Calculator<string>(hello + world): " << cs.add("hello", "world") << "\n";
    
        std::cout << "\ndecltype для возвращаемого типа\n";
        std::cout << "square(5): " << square(5) << "\n";
        std::cout << "square(3.14): " << square(3.14) << "\n";
        return 0;
    }


## Объяснение всех уникальных и важных строк в программе

- template - объявление шаблона функции с одним параметром-типом T

- T maximumValue(T a, T b) { return (a > b) ? a : b; } - шаблон функции для нахождения максимума двух значений любого типа с оператором >

- auto maximumValue(T1 a, T2 b) { return (a > b) ? a : b; } - перегруженный шаблон для сравнения значений разных типов, auto позволяет автоматически вывести тип возвращаемого значения

- void printContainer(const Container& container) { ... } - функция для вывода любого контейнера STL

- for (const auto& elem : container) { ... } - range-based for loop с автоматическим выводом типа элемента через auto

- void printRange(Iterator begin, Iterator end) { ... } - функция для вывода диапазона через пару итераторов

- auto it = begin; - автоматический вывод типа итератора

- template<typename T, std::size_t N> - шаблон функции с параметром-типом T и параметром-значением N (размер массива)

- void printArray(const T (&arr)[N]) { ... } - функция для вывода встроенного массива фиксированного размера

- const T (&arr)[N] - ссылка на константный массив типа T размера N

- auto sumRange(T begin, T end) { ... } - функция для вычисления суммы элементов диапазона

- typename std::remove_reference<decltype(*begin)>::type{} - получение типа элемента без ссылки для инициализации суммы нулевым значением

- typename std::remove_reference<...>::type - удаление ссылки из типа

- class DataContainer { ... } - класс-шаблон для хранения данных произвольного типа

- DataContainer() : data(T{}) {} - конструктор по умолчанию, инициализирует data значением по умолчанию для типа T

- DataContainer(T value) : data(value) {} - конструктор с параметром для инициализации значением

- T getData() const { return data; } - константный метод для получения значения (не модифицирует объект)

- void setData(T value) { data = value; } - метод для установки нового значения

- struct Point { ... } - структура-шаблон для представления точки с координатами произвольного типа

- Point() : x(T{}), y(T{}) {} - конструктор по умолчанию с инициализацией нулями

- Point(T xVal, T yVal) : x(xVal), y(yVal) {} - конструктор с параметрами для задания координат

- T calculateSum(T first) { return first; } - функция для суммирования одного аргумента возвращает его значение

- template<typename T, typename... Args> - вариадический шаблон для произвольного количества аргументов

- T calculateSum(T first, Args... rest) { ... } - рекурсивное суммирование первого аргумента с суммой остальных

- return first + calculateSum(rest...); - рекурсивный вызов с распаковкой параметров пакета Args...

- template<typename... Args> - вариадический шаблон для функции с произвольным количеством аргументов

- void printValues(Args... args) { ... } - функция для вывода произвольного количества значений

- ((std::cout << args << " "), ...); - fold expression (C++17) для вывода всех аргументов через запятую

- template<typename T, typename... Args> - вариадический шаблон для проверки равенства всех аргументов

- bool allEqual(T first, Args... rest) { return ((first == rest) && ...); } - fold expression с логическим И для проверки равенства

- (first == rest) && ... - бинарный fold expression слева направо

- auto multiplyAll(Args... args) { return (args * ...); } - унарный fold expression для умножения всех аргументов

- (args * ...) - унарный fold expression с оператором *

- template<template<typename, typename...> class Container, typename T, typename... Args> - шаблон с параметром-шаблоном

- Container makeContainer(Args... args) { ... } - функция для создания контейнера произвольного типа

- template<template<typename, typename...> class Container> - параметр-шаблон, принимающий шаблон контейнера

- ((c.insert(c.end(), args)), ...); - fold expression для вставки всех аргументов в контейнер

- template<std::size_t N, typename T> - шаблон с параметром размера N и типом T

- constexpr T arraySumImpl(const std::array<T, N>& arr, std::size_t idx) { ... } - constexpr функция для вычисления суммы элементов массива во время компиляции

- if (idx >= N) return T{}; - условие выхода из рекурсии

- return arr[idx] + arraySumImpl(arr, idx + 1); - рекурсивное суммирование элементов

- constexpr T arraySum(const std::array<T, N>& arr) { ... } - публичная constexpr функция для суммирования массива

- void reversePrint(T begin, T end) { ... } - рекурсивная функция для вывода элементов в обратном порядке

- reversePrint(begin, end); - рекурсивный вызов с уменьшенным end

- class Calculator { ... } - класс-шаблон для выполнения арифметических операций

- T add(T a, T b) { return ... } - метод сложения, вычитания, умножения и дедления

- class Calculatorstd::string { ... } - полная специализация шаблона для типа std::string

- std::string add(std::string a, std::string b) { return a + b; } - перегрузка сложения для строк (конкатенация)

- auto square(T value) -> decltype(value * value) { ... } - функция для возведения в квадрат с явным указанием возвращаемого типа

- auto lambda = [](int n) { return n * 2; }; - автоматический вывод типа лямбда-функции


