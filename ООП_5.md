# Лабораторная работа 5
## Обобщенное программирование, шаблоны функций, статический полиморфизм
### Задание
Необходимо написать код, который иллюстрирует использование шаблонов в языке С++. С помощью ключевых слов auto и template нужно написать обобщенные функции, которые принимают диапазоны любой длины, объекты любого типа, произвольное количество аргументов.




## Код программы
    #include <iostream>
    #include <vector>
    #include <list>
    #include <deque>
    #include <array>
    #include <type_traits>
    #include <string>
    #include <sstream>
    
    template<typename T>
    T maximumValue(T a, T b) {
        return (a > b) ? a : b;
    }
    
    template<typename T1, typename T2>
    auto maximumValue(T1 a, T2 b) {
        return (a > b) ? a : b;
    }
    
    template<typename Container>
    void printContainer(const Container& container) {
        for (const auto& elem : container) {
            std::cout << elem << " ";
        }
        std::cout << "\n";
    }
    
    template<typename Iterator>
    void printRange(Iterator begin, Iterator end) {
        for (auto it = begin; it != end; ++it) {
            std::cout << *it << " ";
        }
        std::cout << "\n";
    }
    
    template<typename T, std::size_t N>
    void printArray(const T (&arr)[N]) {
        for (std::size_t i = 0; i < N; ++i) {
            std::cout << arr[i] << " ";
        }
        std::cout << "\n";
    }
    
    template<typename T>
    auto sumRange(T begin, T end) {
        auto total = typename std::remove_reference<decltype(*begin)>::type{};
        for (auto it = begin; it != end; ++it) {
            total += *it;
        }
        return total;
    }
    
    template<typename T>
    class DataContainer {
    private:
        T data;
    public:
        DataContainer() : data(T{}) {}
        DataContainer(T value) : data(value) {}
        T getData() const { return data; }
        void setData(T value) { data = value; }
    };
    
    template<typename T>
    struct Point {
        T x;
        T y;
        Point() : x(T{}), y(T{}) {}
        Point(T xVal, T yVal) : x(xVal), y(yVal) {}
    };
    
    template<typename T>
    T calculateSum(T first) {
        return first;
    }
    
    template<typename T, typename... Args>
    T calculateSum(T first, Args... rest) {
        return first + calculateSum(rest...);
    }
    
    template<typename... Args>
    void printValues(Args... args) {
        ((std::cout << args << " "), ...);
        std::cout << "\n";
    }
    
    template<typename T, typename... Args>
    bool allEqual(T first, Args... rest) {
        return ((first == rest) && ...);
    }
    
    template<typename... Args>
    auto multiplyAll(Args... args) {
        return (args * ...);
    }
    
    template<template<typename, typename...> class Container, typename T, typename... Args>
    Container<T> makeContainer(Args... args) {
        Container<T> c;
        ((c.insert(c.end(), args)), ...);
        return c;
    }
    
    template<std::size_t N, typename T>
    constexpr T arraySumImpl(const std::array<T, N>& arr, std::size_t idx) {
        if (idx >= N) return T{};
        return arr[idx] + arraySumImpl(arr, idx + 1);
    }
    
    template<std::size_t N, typename T>
    constexpr T arraySum(const std::array<T, N>& arr) {
        return arraySumImpl(arr, 0);
    }
    
    template<typename T>
    void reversePrint(T begin, T end) {
        if (begin == end) return;
        --end;
        std::cout << *end << " ";
        reversePrint(begin, end);
    }
    
    template<typename T>
    class Calculator {
    public:
        T add(T a, T b) { return a + b; }
        T subtract(T a, T b) { return a - b; }
        T multiply(T a, T b) { return a * b; }
        T divide(T a, T b) { return a / b; }
    };
    
    template<>
    class Calculator<std::string> {
    public:
        std::string add(std::string a, std::string b) { return a + b; }
        std::string subtract(std::string a, std::string) { return a; }
        std::string multiply(std::string, std::string) { return ""; }
        std::string divide(std::string, std::string) { return ""; }
    };
    
    template<typename T>
    T identity(T value) {
        return value;
    }
    
    template<typename T>
    auto square(T value) -> decltype(value * value) {
        return value * value;
    }
    
    int main() {
        std::cout << "Шаблоны функций: maximumValue\n";
        std::cout << "max(5, 3): " << maximumValue(5, 3) << "\n";
        std::cout << "max(3.14, 2.71): " << maximumValue(3.14, 2.71) << "\n";
        std::cout << "max('a', 'z'): " << maximumValue('a', 'z') << "\n";
        std::cout << "max(5, 3.14): " << maximumValue(5, 3.14) << "\n\n";
    
        std::cout << "auto и вывод типов\n";
        auto x = 42;
        auto y = 3.14159;
        auto z = x + y;
        std::cout << "auto x = 42: " << x << "\n";
        std::cout << "auto y = 3.14159: " << y << "\n";
        std::cout << "auto z = x + y: " << z << "\n";
        auto lambda = [](int n) { return n * 2; };
        std::cout << "auto lambda(10): " << lambda(10) << "\n\n";
    
        std::cout << "Шаблоны для контейнеров\n";
        std::vector<int> v = {1, 2, 3, 4, 5};
        std::list<std::string> lst = {"one", "two", "three"};
        std::deque<double> dq = {1.1, 2.2, 3.3};
    
        printContainer(v);
        printContainer(lst);
        printContainer(dq);
    
        std::cout << "\nprintRange с итераторами\n";
        printRange(v.begin(), v.end());
        printRange(dq.begin(), dq.end());
    
        std::cout << "\nprintArray для встроенных массивов\n";
        int arr[] = {10, 20, 30, 40, 50};
        printArray(arr);
        double arr2[] = {1.1, 2.2, 3.3};
        printArray(arr2);
    
        std::cout << "\nsumRange с автоматическим выводом\n";
        std::vector<int> v2 = {1, 2, 3, 4, 5};
        std::cout << "Сумма вектора: " << sumRange(v2.begin(), v2.end()) << "\n";
    
        std::cout << "\nКласс-шаблон DataContainer\n";
        DataContainer<int> ic(42);
        DataContainer<std::string> sc("Hello");
        std::cout << "DataContainer<int>: " << ic.getData() << "\n";
        std::cout << "DataContainer<string>: " << sc.getData() << "\n";
    
        std::cout << "\nСтруктура-шаблон Point\n";
        Point<int> p1(10, 20);
        Point<double> p2(3.5, 7.2);
        std::cout << "Point<int>: (" << p1.x << ", " << p1.y << ")\n";
        std::cout << "Point<double>: (" << p2.x << ", " << p2.y << ")\n";
    
        std::cout << "\nВариадические шаблоны: calculateSum\n";
        std::cout << "sum(1, 2, 3, 4, 5): " << calculateSum(1, 2, 3, 4, 5) << "\n";
        std::cout << "sum(1.5, 2.5, 3.0): " << calculateSum(1.5, 2.5, 3.0) << "\n";
        std::cout << "sum(10): " << calculateSum(10) << "\n";
    
        std::cout << "\nВариадическая функция printValues\n";
        printValues(1, 2.5, "hello", 'a');
        printValues(100, 200, 300);
    
        std::cout << "\nallEqual с fold expression\n";
        std::cout << "allEqual(5, 5, 5): " << (allEqual(5, 5, 5) ? "true" : "false") << "\n";
        std::cout << "allEqual(5, 5, 6): " << (allEqual(5, 5, 6) ? "true" : "false") << "\n";
        std::cout << "allEqual(1): " << (allEqual(1) ? "true" : "false") << "\n";
    
        std::cout << "\nmultiplyAll с fold expression\n";
        std::cout << "multiplyAll(2, 3, 4): " << multiplyAll(2, 3, 4) << "\n";
        std::cout << "multiplyAll(1.5, 2): " << multiplyAll(1.5, 2) << "\n";
    
        std::cout << "\nmakeContainer с параметрическим шаблоном\n";
        auto vec = makeContainer<std::vector, int>(1, 2, 3, 4, 5);
        printContainer(vec);
        auto lst2 = makeContainer<std::list, int>(10, 20, 30);
        printContainer(lst2);
    
        std::cout << "\nconstexpr с if constexpr\n";
        std::array<int, 5> arr3 = {1, 2, 3, 4, 5};
        std::cout << "Сумма массива: " << arraySum(arr3) << "\n";
        std::array<int, 0> emptyArr;
        std::cout << "Сумма пустого массива: " << arraySum(emptyArr) << "\n";
    
        std::cout << "\nreversePrint (рекурсивный шаблон)\n";
        std::vector<int> v3 = {1, 2, 3, 4, 5};
        std::cout << "Обратный вывод: ";
        reversePrint(v3.begin(), v3.end());
        std::cout << "\n";
    
        std::cout << "\nСпециализация шаблона класса\n";
        Calculator<int> ci;
        Calculator<std::string> cs;
        std::cout << "Calculator<int>(5 + 3): " << ci.add(5, 3) << "\n";
        std::cout << "Calculator<string>(hello + world): " << cs.add("hello", "world") << "\n";
    
        std::cout << "\ndecltype для возвращаемого типа\n";
        std::cout << "square(5): " << square(5) << "\n";
        std::cout << "square(3.14): " << square(3.14) << "\n";
        return 0;
    }





template - объявление шаблона функции с одним параметром-типом T

T maximumValue(T a, T b) { return (a > b) ? a : b; } - шаблон функции для нахождения максимума двух значений любого типа с оператором >

auto maximumValue(T1 a, T2 b) { return (a > b) ? a : b; } - перегруженный шаблон для сравнения значений разных типов, auto позволяет автоматически вывести тип возвращаемого значения

void printContainer(const Container& container) { ... } - функция для вывода любого контейнера STL

for (const auto& elem : container) { ... } - range-based for loop с автоматическим выводом типа элемента через auto

void printRange(Iterator begin, Iterator end) { ... } - функция для вывода диапазона через пару итераторов

auto it = begin; - автоматический вывод типа итератора

template<typename T, std::size_t N> - шаблон функции с параметром-типом T и параметром-значением N (размер массива)

void printArray(const T (&arr)[N]) { ... } - функция для вывода встроенного массива фиксированного размера

const T (&arr)[N] - ссылка на константный массив типа T размера N

auto sumRange(T begin, T end) { ... } - функция для вычисления суммы элементов диапазона

typename std::remove_reference<decltype(*begin)>::type{} - получение типа элемента без ссылки для инициализации суммы нулевым значением

typename std::remove_reference<...>::type - удаление ссылки из типа

class DataContainer { ... } - класс-шаблон для хранения данных произвольного типа

DataContainer() : data(T{}) {} - конструктор по умолчанию, инициализирует data значением по умолчанию для типа T

DataContainer(T value) : data(value) {} - конструктор с параметром для инициализации значением

T getData() const { return data; } - константный метод для получения значения (не модифицирует объект)

void setData(T value) { data = value; } - метод для установки нового значения

struct Point { ... } - структура-шаблон для представления точки с координатами произвольного типа

Point() : x(T{}), y(T{}) {} - конструктор по умолчанию с инициализацией нулями

Point(T xVal, T yVal) : x(xVal), y(yVal) {} - конструктор с параметрами для задания координат

T calculateSum(T first) { return first; } - функция для суммирования одного аргумента возвращает его значение

template<typename T, typename... Args> - вариадический шаблон для произвольного количества аргументов

T calculateSum(T first, Args... rest) { ... } - рекурсивное суммирование первого аргумента с суммой остальных

return first + calculateSum(rest...); - рекурсивный вызов с распаковкой параметров пакета Args...

template<typename... Args> - вариадический шаблон для функции с произвольным количеством аргументов

void printValues(Args... args) { ... } - функция для вывода произвольного количества значений

((std::cout << args << " "), ...); - fold expression (C++17) для вывода всех аргументов через запятую

template<typename T, typename... Args> - вариадический шаблон для проверки равенства всех аргументов

bool allEqual(T first, Args... rest) { return ((first == rest) && ...); } - fold expression с логическим И для проверки равенства

(first == rest) && ... - бинарный fold expression слева направо

auto multiplyAll(Args... args) { return (args * ...); } - унарный fold expression для умножения всех аргументов

(args * ...) - унарный fold expression с оператором *

template<template<typename, typename...> class Container, typename T, typename... Args> - шаблон с параметром-шаблоном

Container makeContainer(Args... args) { ... } - функция для создания контейнера произвольного типа

template<template<typename, typename...> class Container> - параметр-шаблон, принимающий шаблон контейнера

((c.insert(c.end(), args)), ...); - fold expression для вставки всех аргументов в контейнер

template<std::size_t N, typename T> - шаблон с параметром размера N и типом T

constexpr T arraySumImpl(const std::array<T, N>& arr, std::size_t idx) { ... } - constexpr функция для вычисления суммы элементов массива во время компиляции

if (idx >= N) return T{}; - условие выхода из рекурсии

return arr[idx] + arraySumImpl(arr, idx + 1); - рекурсивное суммирование элементов

constexpr T arraySum(const std::array<T, N>& arr) { ... } - публичная constexpr функция для суммирования массива

void reversePrint(T begin, T end) { ... } - рекурсивная функция для вывода элементов в обратном порядке

reversePrint(begin, end); - рекурсивный вызов с уменьшенным end

class Calculator { ... } - класс-шаблон для выполнения арифметических операций

T add(T a, T b) { return ... } - метод сложения, вычитания, умножения и дедления

class Calculatorstd::string { ... } - полная специализация шаблона для типа std::string

std::string add(std::string a, std::string b) { return a + b; } - перегрузка сложения для строк (конкатенация)

auto square(T value) -> decltype(value * value) { ... } - функция для возведения в квадрат с явным указанием возвращаемого типа


auto lambda = [](int n) { return n * 2; }; - автоматический вывод типа лямбда-функции
